<!--
@license
Copyright 2017 GIVe Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../basic-func/basic-func.html">
<link rel="import" href="../track-object/tracks-header.html">
<link rel="import" href="../ref-embedded-behavior/ref-embedded-behavior.html">
<link rel="import" href="../tutorial-highlight/tutorial-highlight.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../genemo-styles.html">
<link rel="import" href="./genemo-track-styles.html">
<link href="https://fonts.googleapis.com/css?family=Roboto:500,400italic,700italic,700,400" rel="stylesheet" type="text/css">
<!--
### Overview

`<chart-window>` provides a Web Component element to interactively display
genomic data.

```html
<chart-window group-id-list='["genes", "singleCell"]' ref="mm10"></chart-area>
```

Although `<chart-window>` does not contain the navigational control elements as
in `<chart-controller>`, users may still navigate by dragging and
mouse-wheeling on the coordinates to move around.

Please refer to
[`GIVe.RefEmbeddedBehavior`](../ref-embedded-behavior/index.html) for details
on references used.

### Managing Track Priorities

`<chart-window>` will manage track order once a view has been generated. Its
behavior regarding to track order will be discussed within this section.

#### Before generating a view

`<chart-window>` shall receive an ordered list of all visible tracks from its
embedded `refObject`, the visibility of tracks will be supplied by its
`defaultTrackIdList` property, or (if said property is not set) by the
default `visibility` property of individual tracks.

When the visibility of tracks have been determined, `refObject` will provide
a sorted list (by relative `priorities` property of the tracks) of visible
tracks to start with.

#### Populating the view with tracks

Once `<chart-window>` receives the ordered list of visible tracks, it will:
*   Assign every track's `trackDom`'s `<svg>` element into its
    corresponding slot (`top`, `scroll`, `bottom`, and `inbetween`) by
    inserting it into the corresponding DOM node. Notice that if this window
    is the last window in the view, the slots and track order will be
    reversed to preserve a certain degree of symmetry.
*   Keep record of the relative order for every `<svg>` element within its
    own slot.
    Every track object will have an __`effective priority`__ value consists of
    its slot allocation (`top`, `scroll`, `bottom`, and `inbetween`)
    and its position within the slot.
*   Assign the `y` property for every `<svg>` when drawing the DOM element
    so that it appears in the correct order regardless of its order in the
    DOM tree.

#### Modifying the track list and its effect on track order

##### Adding new tracks

This action may only come from the parent element.

When a new track is being added to the visible list, it will be allocated to
its corresponding slot but __added to the very end of the list__. The
`effective priority` value of the new track will be set if not done yet.

##### Removing a track

This action may come from the parent element or from the `<chart-window>`
itself (via a "delete" button, to be implemented).

When an existing track is being removed, it will be delisted from the slot,
the `trackDom` object will be put into a recycled list (previous recycled list
will be cleared) and all the `visibility` values and `effective priority`
values will be updated accordingly.

If this action comes from the `<chart-window>` itself, notify its parent about
this change.

##### Restoring a track previously removed

This action may only come from the parent element.

When a restoring command was received, all `trackDom`s in the recycled list
will be restored to their corresponding location, their `track`'s `visibility`
properties and `effective priority` values will be adjusted. After that, the
recycled list will be cleared.

##### Changing the location of a track

This action may come from the parent element or from the `<chart-window>`
itself (via drag-drop, to be implemented).

The `effective priority` will be updated to the new locations if the action
comes from `<chart-window>` itself (this happens when user tries to alter the
order of the tracks).

Then the actual `svg` `y` values will be updated to reflect the new location.

If this action comes from the `<chart-window>` itself, notify its parent about
this change.

-->
<dom-module id="chart-window">
  <template>
    <style include="genemo-shared-styles">
      :host {
        position: relative;
        overflow-x: hidden;
        overflow-y: auto;
        font-family: 'Roboto', Arial, Helvetica, sans-serif;
        display: block;
        margin: 0;
        padding: 0;
        width: 100%;
        @apply --layout-vertical;
        @apply --layout-flex;
      }
      div {
        margin: 0;
        padding: 0;
        border: none;
      }
      div.pinnedParts {
        @apply --layout-start;
        overflow: hidden;
      }
      div.scrollingParts {
        @apply --layout-flex;
        overflow-x: hidden;
        overflow-y: auto;
      }
    </style>
    <style include="genemo-track-styles"></style>
    <div id="chartHolding">
      <div class="pinnedParts">
        <svg class="svgHolder" version="1.1" baseProfile="full"
          xmlns="http://www.w3.org/2000/svg" id="_PinTop">
        </svg>
      </div>
      <div class="scrollingParts">
        <svg class="svgHolder" version="1.1" baseProfile="full"
          xmlns="http://www.w3.org/2000/svg" id="_Scroll">
        </svg>
      </div>
      <div class="pinnedParts">
        <svg class="svgHolder" version="1.1" baseProfile="full"
          xmlns="http://www.w3.org/2000/svg" id="_PinBottom">
        </svg>
      </div>
      <div class="pinnedParts">
        <svg class="svgHolder" version="1.1" baseProfile="full"
          xmlns="http://www.w3.org/2000/svg" id="_PinBetween">
        </svg>
      </div>
    </div>
    <template is="dom-if" if="[[showTutorial]]">
      <tutorial-highlight id="coorTrackTutorial"
        tutorial-key="coor-track-tutorial"
        dom-target-id="[[_coorDomSvgId]]">
        <div>
          You may use mouse wheel within the coordinate track to zoom in/out,
          drag any track to move.
        </div>
      </tutorial-highlight>
    </template>
  </template>
  <script>
var GIVe = (function (give) {
  'use strict'

  class ChartWindow extends Polymer.mixinBehaviors([
    give.RefEmbeddedBehavior], Polymer.Element
  ) {
    constructor () {
      super(...arguments)
      this._trackDoms = []
      this._hiddenTrackDoms = []
      this.linkedTrackDoms = {}

      /**
       * _trackDomPromises - an array holding all updating promises of tracks
       *    within `this._trackDoms` __and `this._hiddenTrackDoms`__
       * @type {Array<Promise>}
       */
      this._trackDomPromises = []
      this._addedTrackMap = new Map()
      this._hiddenTrackDomMap = new Map()
      this._linkedTrackDomMap = new Map()

      this._pendingVWindow = null
      this._viewWindow = null
      this._pendingWidth = null

      this._svgSizes = {
        '_PinTop': 0,
        '_Scroll': 0,
        '_PinBottom': 0,
        '_PinBetween': 0
      }

      this._updatingCoor = false
    }

    static get properties () {
      return {
        /**
         * The view windows to display in the element.
         * The members of the properties should be `GIVE.ChromRegion` Objects
         * @type {GIVe.ChromRegion}
         */
        _viewWindow: {
          type: Object
        },

        index: {
          type: Number,
          value: 0
        },

        totalWindows: {
          type: Number,
          value: 1
        },

        _coorDomSvgId: {
          type: String,
          value: ''
        },

        /**
         * The view window to display in the element, in coordinate format.
         * This is for HTML attributes
         */
        coordinate: {
          type: String,
          notify: true,
          observer: '_coorChanged'
        },

        /**
         * The track groups included in the embedded browser. Group IDs are
         * specified in the data source. The data source on our server currently
         * provides these track groups:
         * *  `'genes'`: gene annotation tracks, for all available references
         * *  `'encode'`: ENCODE data sets for human and mouse, for `mm9` and `hg19` only
         * *  `'interaction'`: genomic interaction data sets, including those
         * generated from Hi-C (chromatin-chromatin) and MARGI (RNA-chromatin)
         * data, for `mm10`, `hg38` (MARGI) and `hg19` (Hi-C)
         * *  `'singleCell'`: mouse embryo single-cell RNA-seq data set from
         * [Biase *et al.*, *Genome Research*, **24**:1787-1796](http://genome.cshlp.org/content/24/11/1787.full),
         * for `mm10` only
         * @type {Array.<string>}
         */
        groupIdList: {
          // this is the array of allowed group IDs in the list
          type: Array,
          value: function () {
            return []
          }
        },

        defaultTrackIdList: {
          type: Array,
          value: function () {
            return []
          }
        },

        _initialized: {
          type: Boolean,
          value: false
        },

        trackGap: Number,
        textSize: Number,
        textMargin: Number,

        /**
         * Promise resolved to the current `viewWindow` when the entire
         * `chart-window` is ready.
         * When resolved, this value will be set to `null`
         * @type {Promise}
         */
        drawingPromise: {
          type: Object,
          value: null
        },

        /**
         * Flag to indicate whether this is the first time this `chart-area`
         * element is run
         * @type {boolean}
         */
        firstRun: {
          type: Boolean,
          notify: true
        },

        showTutorial: {
          type: Boolean,
          value: false
        }
      }
    }

    ready () {
      super.ready()
      // initialize this._viewWindows from this.coordinates
      if (this.defaultTrackIdList.length > 0) {
        this._needOverrideDefault = true
      }

      this.windowWidth = this.querySelector('#chartHolding').clientWidth

      this.addEventListener('track-ready', this._trackReadyHandler)
      this.addEventListener('update-window', this._updateWindowHandler)

      if (this.coordinate) {
        this._coorChanged(this.coordinate)
      }
    }

    attached () {
      if (!this._initialized) {
        Promise.resolve().then(() => this._initDomAfterVWinRefReady())
      }
    }

    get reverseFlag () {
      return this.index > 0 && this.index === this.totalWindows - 1
    }

    get initialized () {
      return this._initialized
    }

    _initDomAfterVWinRefReady (newWindow) {
      if (this._refObj &&
        (newWindow || this._viewWindow || this._pendingVWindow)
      ) {
        this._initialized = true
        return this.resetDOM(newWindow)
      }
      this._updateCoordinates()
      return false
    }

    /**
     * Merge properties together
     * @todo Will be changed into `track-dom-behavior` or `basic-funcs`
     *
     * @param  {object} original - original object
     * @param  {object} newProp - object with new properties
     * @returns {object} object with the merged properties
     */
    _mergeProperty (original, newProp) {
      for (var key in newProp) {
        if (newProp.hasOwnProperty(key)) {
          original[key] = newProp[key]
        }
      }
      return original
    }

    _createTrackProp (props) {
      props = props || {}
      props.windowIndex = this.index
      props.width = this.$.chartHolding.clientWidth
      props.textMargin = this.textMargin
      return props
    }

    _getSlotId (track, honorEffPriority) {
      if (honorEffPriority && track.effPriority) {
        return this._slotIdFromPinValue(
          track.effPriority.pinValue
        )
      } else if (track.windowSpan > 1) {
        if (this.index + track.windowSpan > this.totalWindows) {
          return null
        }
        return '_PinBetween'
      } else {
        return this._slotIdFromPinValue(track.getSetting('pin'))
      }
    }

    _slotIdFromPinValue (pinValue) {
      pinValue = pinValue || ''
      switch (pinValue.toLowerCase()) {
        case 'top':
          return this.reverseFlag ? '_PinBottom' : '_PinTop'
        case 'bottom':
          return this.reverseFlag ? '_PinTop' : '_PinBottom'
        case 'inbetween':
          return '_PinBetween'
        default:
          return '_Scroll'
      }
    }

    _pinValueFromSlotId (slotId) {
      switch (slotId.toLowerCase()) {
        case '_PinTop':
          return this.reverseFlag ? 'bottom' : 'top'
        case '_PinBottom':
          return this.reverseFlag ? 'top' : 'bottom'
        case '_PinBetween':
          return 'inbetween'
        default:
          return 'scroll'
      }
    }

    _findEffPriorIndex (effPriority) {
      return give.locationOf(effPriority, this._trackDoms, null, null,
        (effPriority, dom2) => give.EffPrior.compare(
          effPriority, dom2.parent.effPriority
        ), true
      )
    }

    _addTrackDomSvg (trackDom, honorEffPriority) {
      if (trackDom && !this._addedTrackMap.has(trackDom.parent.id)) {
        let slotId = this._getSlotId(trackDom.parent, honorEffPriority)
        if (slotId) {
          if (!trackDom.parent.effPriority) {
            trackDom.parent.effPriority =
              new give.EffPrior(this._pinValueFromSlotId(slotId),
                this._svgSizes[slotId])
          }
          // Add DOM element
          this.shadowRoot.querySelector('#' + slotId)
            .appendChild(trackDom.trackSvg)
          // Find the correct location of the new DOM
          let domPos = this._findEffPriorIndex(trackDom.parent.effPriority)
          if (this._trackDoms[domPos] &&
            !give.EffPrior.compare(this._trackDoms[domPos].parent.effPriority,
              trackDom.parent.effPriority)
          ) {
            // Update all effPriority values for DOMs after the new DOM
            for (let i = domPos;
              i < this._trackDoms.length &&
              this._trackDoms[i].parent.effPriority.pinValue ===
              trackDom.parent.effPriority.pinValue;
              i++
            ) {
              this._trackDoms[i].parent.effPriority.pos += 1
            }
          }
          // Insert the new DOM into its correct location
          this._trackDoms.splice(domPos, 0, trackDom)

          this._addedTrackMap.set(trackDom.parent.id, trackDom)
          this._svgSizes[slotId]++
          return slotId
        }
      }
      return null
    }

    _addVisibleTrack (track, props, honorEffPriority) {
      if (!this._addedTrackMap.has(track.id)) {
        let newTrackDom = track.createDomObj(this._createTrackProp(props))
        this._addTrackDomSvg(newTrackDom, honorEffPriority)
        if (newTrackDom.linkedIndices) {
          this.
        }
        return newTrackDom.linkedIndices ? newTrackDom : null
      }
      return null
    }

    _addHiddenTrack (trackDom) {
      if (trackDom && !this._hiddenTrackDomMap.has(trackDom.id)) {
        this._hiddenTrackDoms.push(trackDom)
        this._hiddenTrackDomMap.set(trackDom.id, trackDom)
      }
    }

    _removeTrack (tracks) {
      if (!Array.isArray) {
        tracks = [tracks]
      }
      let visibleTracksChanged = false
      tracks.forEach(track => {
        if (this._addedTrackMap.has(track.id)) {
          let trackDom = this._addedTrackMap.get(track.id)
          // This track is visible, remove the <svg> element from its slot
          this.shadowRoot.querySelector(
            '#' + this._slotIdFromPinValue(track.effPriority.pinValue)
          ).removeChild(trackDom.trackSvg)
          // Then remove the DOM itself
          this._trackDoms = this._trackDoms.filter(dom => {
            return dom !== trackDom
          })
          // set flag to update effPriority values
          visibleTracksChanged = true
          this._addedTrackMap.delete(track.id)
        } else {
          give._verbConsole.warn('Track ID "' + track.id + '" does not exist!')
        }
      })

      if (visibleTracksChanged) {
        // Update all effPriority values affected
        for (let slotId in this._svgSizes) {
          if (this._svgSizes.hasOwnProperty(slotId)) {
            this._svgSizes[slotId] = 0
          }
        }
        this._trackDoms.forEach(trackDom => {
          let slotId = this._pinValueFromSlotId(
            trackDom.parent.effPriority.pinValue)
          trackDom.parent.effPriority.pos = this._svgSizes[slotId].length
          this._svgSizes[slotId]++
        })
      }
    }

    _removeHiddenTrackDom (trackDomId) {

    }

    /**
     * _trackEffPriorUpdated - this is used when the `effPriority` values
     *    __has been updated for all `track`s__ in the parent element, and the
     *    DOM array order needs to be restored.
     *
     * @param  {TrackObjectBase} track - the track whose `effPriority` has
     *    changed
     */
    _trackEffPriorUpdated (track, oldIndex, newIndex) {
      if (track && this._addedTrackMap.has(track.id)) {
        throw new give.GiveError('Track does not exist for track "' +
          track && track.id + '"!')
      }
      if (this._addedTrackMap.get(track.id).visible) {
        let trackDom = this._addedTrackMap.get(track.id).trackDom
        let oldIndex = this._trackDoms.indexOf(trackDom)
        if (oldIndex >= 0) {
          this._moveTrackDom(oldIndex,
            this._findEffPriorIndex(trackDom.parent.effPriority))
        } else {
          throw new give.GiveError('TrackDOM does not exist for track "' +
            track.id + '"!')
        }
      }
    }

    _moveTrackDom (oldIndex, newIndex) {
      let trackDom = this._trackDoms[oldIndex]
      this._trackDoms.splice(oldIndex, 1)
      this._trackDoms.splice(
        this._findEffPriorIndex(trackDom.parent.effPriority), 0, trackDom)
    }

    _clearDOM () {
      // clear out all the svgs
      var svgList = [...this.shadowRoot.querySelectorAll('.svgHolder')]
      svgList.forEach(svgElem => {
        while (svgElem.firstChild) {
          svgElem.removeChild(svgElem.firstChild)
        }
      }, this)
      // reset slot sizes
      for (let slotId in this._svgSizes) {
        if (this._svgSizes.hasOwnProperty(slotId)) {
          this._svgSizes[slotId] = 0
        }
      }
      // clear `this._trackDoms`
      this._trackDoms.length = 0
    }

    /**
     * _changeTrackEffPrior - change the `effPriority` value of the `track`
     *    given the `trackDom`
     *
     * @param  {TrackDom} trackDom       The `trackDom` for which `effPriority`
     *    needs to be changed.
     * @param  {give.EffPrior} newEffPriority The new `effPriority` value.
     *    Notice that the `pos` value is the new position of the `trackDom`
     *    as if its just being inserted. Therefore, it __should not consider
     *    the position of `trackDom` itself__ if the new location is after
     *    the original one.
     */
    _changeTrackEffPrior (trackDom, newEffPriority) {
      if (trackDom && newEffPriority) {
        let oldEffPriority = trackDom.parent.effPriority
        if (give.EffPrior.compare(oldEffPriority, newEffPriority)) {
          // determine if the pin value has changed
          let oldIndex = this._trackDoms.indexOf(trackDom)
          let newIndex = this._findEffPriorIndex(newEffPriority)
          if (oldEffPriority.pinValue === newEffPriority.pinValue) {
            // same pin value, just change the tracks in between
            let step = Math.sign(newIndex - oldIndex)
            for (let i = oldIndex + step;
              i * step <= newIndex * step;
              i += step
            ) {
              this._trackDoms[i].parent.effPriority.pos -= step
            }
          } else {
            // pin value is different, separate into two steps
            // -1 for all tracks with the old pin value and pos > oldPos
            for (let i = oldIndex + 1;
              i < this._trackDoms.length &&
                this._trackDoms[i].parent.effPriority.pinValue ===
                  oldEffPriority.pinValue;
              i++
            ) {
              this._trackDoms[i].parent.effPriority.pos -= 1
            }
            // +1 for all tracks with the new pin value and pos >= newPos
            for (let i = newIndex;
              i < this._trackDoms.length &&
                this._trackDoms[i].parent.effPriority.pinValue ===
                  newEffPriority.pinValue;
              i++
            ) {
              this._trackDoms[i].parent.effPriority.pos += 1
            }
          }
          trackDom.parent.effPriority = newEffPriority
          this._moveTrackDom(oldIndex, newIndex)
        } else {
          give._verbConsole.warn('Effective priority not changed.')
        }
      } else {
        throw new give.GiveError('No TrackDOM or effPriority provided!')
      }
    }

    updateSvgHeightLocation (width) {
      // update width and throw width if needed
      width = width || this.querySelector('#chartHolding').clientWidth

      let svgList = [...this.shadowRoot.querySelectorAll('.svgHolder')]

      svgList.forEach(svgElem => {
        svgElem.setAttribute('width', width)
        svgElem.setAttribute('height', svgElem._currY || 0)
        svgElem.setAttribute('viewBox',
          '0 0 ' + width + ' ' + svgElem._currY || 0)
        delete svgElem._currY
      })
      if (
        width === this.querySelector('#chartHolding').clientWidth &&
        this.querySelector('.scrollingParts').clientWidth < width
      ) {
        throw this.querySelector('.scrollingParts').clientWidth
      }
      this.windowWidth = width
    }

    /**
     * @function updateTracks
     * @async
     * @param  {ChromRegionLiteral} newVWindow - Whether the view window needs
     *    to be changed to the new window, if this is `false`, then the
     *    function will return a resolved `Promise`.
     * @param  {number} [width] - If a new width is need to be specified
     * @return {Promise<ChromRegionLiteral>} Returns a Promise that resolves
     *    to the new window when new data was ready.
     * @throws {number} if width needs to be changed (due to scroll bar), the
     *    new width will be thrown to let the calling function (in
     *    `chart-area`) be informed of incoming width change.
     */
    updateTracks (newVWindow, width) {
      // Steps:
      // * Update all tracks' width and height (with maybe new view window)
      // * Calculate whether a scroll bar will be needed and rearrange all
      //   the svg elements by changing the Y value
      //   (by calculating and setting the height of the svgHolder element)
      //   * If a scroll bar is needed, throw the width with scroll bar
      //     factored in. Process ends to wait for the next call from the
      //     parent element (`chart-area`).
      // * Resolve the promise to the new view window
      give._verbConsole.info(
        'updateTracks(' + width + ', ' + newVWindow + ')')

      // prepare element widths and heights
      this._pendingVWindow = newVWindow || this._pendingVWindow || false
      this._updateCoordinates()

      width = width || this.querySelector('#chartHolding').clientWidth

      // Update all tracks' width and height (with maybe new view window)
      // If no new promise is needed, do not chain stuff afterwards
      let newdrawingPromise = give.getAggregatedUpdatePromise(
        this._trackDomPromises,
        this._trackDoms.concat(this._hiddenTrackDoms),
        trackDom => trackDom.update(newVWindow, width, null, null, this.index)
      )

      if (newdrawingPromise) {
        // * Calculate whether a scroll bar will be needed
        //   (by calculating and setting the height of the svgHolder element)
        //   * If a scroll bar is needed, throw the width with scroll bar
        //     factored in. Process ends to wait for the next call from the
        //     parent element (`chart-area`).
        this.drawingPromise = newdrawingPromise.then(
          windows => this._trackReadyHandler(windows, width)
        )
      }

      return this.drawingPromise
    }

    _showTutorialIfNeeded () {
      if (this.firstRun && this.showTutorial &&
        this._coorDomSvg
      ) {
        this.$.coorTrackTutorial.domTargetId =
          this._coorDomSvg.id
        this.$.coorTrackTutorial.showTutorial()
      }
      this.firstRun = false
    }

    _updateTrackLocation (newWidth) {
      let enumArray = this.reverseFlag
        ? this.trackdoms.slice().reverse() : this.trackdoms
      enumArray.forEach(trackDom => {
        let svgElem = this.shadowRoot.querySelector(
          '#' + this._getSlotId(trackDom.parent, true)
        )
        if (svgElem.hasOwnProperty('_currY')) {
          svgElem._currY += this._trackGap * this._textSize
        } else {
          svgElem._currY = 0
        }
        trackDom.updateLocation(0, svgElem._currY)
        svgElem._currY += trackDom.height
      })
      this.updateSvgHeightLocation(newWidth)
    }

    _trackReadyHandler (windows, newWidth) {
      // First check whether other resizing event fired before
      // this update (otherwise the display may not be up-to-date).
      let pendingVWindow = this._pendingVWindow || this._viewWindow
      this._trackDomPromises.length = 0
      if (pendingVWindow && Array.isArray(windows) && windows.some(
        window => give.ChromRegion.compare(window, this._pendingVWindow)
      )) {
        throw new give.PromiseCanceller(true)
      }
      // update `this._viewWindow` and clear `this.drawingPromise`
      // `windows` is the array returned by Promise.all()
      delete this.drawingPromise
      this._viewWindow = pendingVWindow
      this._pendingVWindow = null
      this._updateTrackLocation(newWidth)
      // call tutorial elements if needed
      try {
        this._showTutorialIfNeeded()
      } catch (e) {
        give._verbConsole.warn(e)
        give.fireSignal('warning', { msg: e.message }, null, this)
      } finally {
        this._readiness = true
      }
      return this._viewWindow
    }

    getVerifiedViewWindow (coordinate) {
      try {
        // This may throw some exceptions
        // (when invalid view windows are supplied)
        return new give.ChromRegion(coordinate, this._refObj)
      } catch (err) {
        // Invalid view windows are supplied, fail gracefully
        err.data = err.data || {}
        err.data.updatedCoor =
          (this._viewWindow &&
            this._viewWindow.regionToString
          ) ? this._viewWindow.regionToString(false) : null
        throw err
      }
    }

    /**
     * _changeViewWindow - Change the range of a sub view.
     *    The range should be a `GIVE.ChromRegion` object and clipped.
     *    No exceptions should be thrown from this function.
     *
     * @param  {ChromRegionLiteral} viewWindow - The target range
     * @return {Promise<ChromRegionLiteral>} A Promise that resolves to the
     *    updated view window when the updating is done.
     * @throws {number} if width needs to be changed (due to scroll bar), the
     *    new width will be thrown to let the calling function (in
     *    `chart-area`) be informed of incoming width change.
     */
    changeViewWindow (viewWindow) {
      if (!this._initialized) {
        return this._initDomAfterVWinRefReady(viewWindow)
      } else {
        return this.updateTracks(viewWindow, null, this.index)
      }
    }

    _coorChanged (newValue, oldValue) {
      if (!this._updatingCoor) {
        try {
          let newWindow = this.getVerifiedViewWindow(newValue)
          let currWindow = this._pendingVWindow || this._viewWindow
          if (give.ChromRegion.compare(currWindow, newWindow)) {
            this.changeViewWindow(newWindow)
          }
        } catch (err) {
          err.data = err.data || {}
          err.data.updatedCoor =
            (this._viewWindow && this._viewWindow.regionToString)
              ? this._viewWindow.regionToString(false) : null
          this._updateCoordinates()
          throw err
        }
      }
    }

    _updateCoordinates (window) {
      window = window || this._pendingVWindow || this._viewWindow
      if (window) {
        this._updatingCoor = true
        this.coordinate = window.regionToString(false)
        this._updatingCoor = false
      }
    }

    /**
     * Get the `string` of ranges in all views
     *
     * @returns {Array<string>} The ranges, converted to `string`.
     */
    getViewWindowString () {
      return this._viewWindows.map(function (vwindow, index) {
        return vwindow.regionToString(false)
      }, this)
    }

    /**
     * _addTracksFromDefaultList - Add tracks based on
     *    `this.defaultTrackIdList` instead of the default values in
     *    the database
     */
    _addTracksFromDefaultList () {
      this._refObj.tracks.forEach(
        track => track.setSetting('visibility', false)
      )
      let exceptions = []
      let result = this.defaultTrackIdList.map(
        id => {
          try {
            if (this._refObj.tracks.hasTrack(id)) {
              this._refObj.tracks.get(id).setSetting('visibility', true)
              return this._addVisibleTrack(this._refObj.tracks.get(id))
            } else {
              throw new give.GiveError(
                'Track ID `' + id + '` does not exist in ref ' +
                this._refObj.id)
            }
          } catch (err) {
            err.message = '[Adding Track `' + id + '`] ' + err.message
            exceptions.push(err)
            return null
          }
        }
      ).filter(item => !!item)
      if (exceptions.length > 0) {
        let message = exceptions.reduce(
          (prev, currErr) => (prev + '\n' + currErr.message),
          'Exception occured when adding tracks:'
        )
        give._verbConsole.warn(message)
        give.fireSignal('warning', { msg: message }, null, this)
      }
      return result
    }

    /**
     * _addTracksFromVisibilitySettings - Add tracks based on the default
     *    `visibility` values in the database (via `track.isVisible`).
     *    Note that `this.groupIdList` will determine the track groups that
     *    will be shown here.
     */
    _addTracksFromVisibilitySettings () {
      let exceptions = []
      let showTrack =
        track => (track.isVisible ? this._addVisibleTrack(track) : null)
      if (this.groupIdList && this.groupIdList.length > 0) {
        this.groupIdList.forEach(groupID => {
          if (this._refObj.groups.hasOwnProperty(groupID)) {
            this._refObj.groups[groupID].forEach(showTrack)
          }
        })
      } else {
        this._refObj.tracks.forEach(showTrack)
      }
    }

    _setRefObj (refObj) {
      this._refObj = refObj
      this._initialized = false
      give.fireSignal('ref-changed', {
        ref: refObj.db,
        index: this.index
      }, null, this)
      return this._initDomAfterVWinRefReady()
    }

    _initDOMCoorTrack () {
      if (this._refObj) {
        let coorTrack = give.TrackObject.createTrack(
          'coor_' + this._refObj.db,
          null, this._refObj, 'coordinate'
        )
        this._coorDomSvg = this._addVisibleTrack(coorTrack).TrackSvg
      }
    }

    /**
     * Reset the entire DOM display
     */
    resetDOM (newWindow) {
      if (this._initialized) {
        this._clearDOM()
        this._readiness = false
        this._initDOMCoorTrack()
        return this.addAllTrackDoms(newWindow)
      } else {
        this._readiness = true
        return Promise.resolve(this._viewWindow)
      }
    }

    addAllTrackDoms (newWindow, noRefreshContent) {
      return this._refObj.initTracks().then(refObj => {
        if (refObj.db !== this.ref) {
          // Only respond to this call if ref has not been changed
          throw new give.PromiseCanceller(true)
        }
        if (this._needOverrideDefault) {
          // use this.defaultTrackIdList to directly fill in the DOM array
          // without sorting by priority (use the defaultTrackIdList order)
          this._addTracksFromDefaultList()
          delete this._needOverrideDefault
        } else {
          // no default tracks supplied, use groupIdList filter and
          // visibility settings
          // sort by priorities defined in database (this should be done
          //    in `this._refObj` already)
          this._addTracksFromVisibilitySettings()
        }
        if (newWindow || !noRefreshContent) {
          return this.updateTracks(newWindow, null, this.index)
        } else {
          return Promise.resolve(this._viewWindow)
        }
      })
    }

    _removeInvisibleTrackDoms () {
      // Find tracks from `this._trackDoms` that become invisible now
      // then call `this._removeTrack` to remove them
      let removedTracks = this._trackDoms.map(trackDom => trackDom.parent)
        .filter(track => !track.isVisible)
      this._removeTrack(removedTracks)
    }

    updateDOM (newWindow, noRefreshContent) {
      if (!this._initialized) {
        return this._initDomAfterVWinRefReady(viewWindow)
      }
      // update existing DOMs, first remove all tracks that should be hidden
      // if noRefreshContent = true, do not refresh content
      // (should be refreshed later)
      if (this._trackDoms && this._trackDoms.length > 0) {
        this._removeInvisibleTrackDoms()
      }

      // then add new Tracks (if not there already)
      return this.addAllTrackDoms(newWindow, noRefreshContent)
    }

    _updateWindowHandler (e) {
      // update the windows by events bubbled up from bottom tracks
      try {
        if (e.detail.newVWindow instanceof give.ChromRegion ||
          typeof e.detail.newVWindow === 'string'
        ) {
          if (e.detail.tracks) {
            return this.updateDOM(e.detail.newWindow)
          } else {
            return this.changeViewWindow(e.detail.newVWindow)
          }
        }
      } catch (err) {
        give._verbConsole.warn(err)
      }
    }

    updateWindow (e) {
      return this._updateWindowHandler(e)
    }
  }

  give.ChartWindow = ChartWindow
  window.customElements.define('chart-window', give.ChartWindow)

  return give
})(GIVe || {})
  </script>
</dom-module>
