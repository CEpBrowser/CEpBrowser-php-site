<!--
@license
Copyright 2017 GIVe Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../basic-func/basic-func.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../track-object/tracks-header.html">
<link rel="import" href="../ref-embedded-behavior/ref-embedded-behavior.html">
<link rel="import" href="../tutorial-highlight/tutorial-highlight.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../genemo-styles.html">
<link rel="import" href="genemo-track-styles.html">
<link href="https://fonts.googleapis.com/css?family=Roboto:500,400italic,700italic,700,400" rel="stylesheet" type="text/css">
<!--
### Overview

`<chart-window>` provides a Web Component element to interactively display
genomic data.

```html
<chart-window group-id-list='["genes", "singleCell"]' ref="mm10"></chart-area>
```

Although `<chart-window>` does not contain the navigational control elements as
in `<chart-controller>`, users may still navigate by dragging and
mouse-wheeling on the coordinates to move around.

Please refer to
[`GIVe.RefEmbeddedBehavior`](../ref-embedded-behavior/index.html) for details
on references used.

### Managing Track Priorities

`<chart-window>` will manage track order once a view has been generated. Its
behavior regarding to track order will be discussed within this section.

#### Before generating a view

`<chart-window>` shall receive an ordered list of all visible tracks from its
embedded `refObject`, the visibility of tracks will be supplied by its
`defaultTrackIdList` property, or (if said property is not set) by the
default `visibility` property of individual tracks.

When the visibility of tracks have been determined, `refObject` will provide
a sorted list (by relative `priorities` property of the tracks) of visible
tracks to start with.

#### Populating the view with tracks

Once `<chart-window>` receives the ordered list of visible tracks, it will:
*   Assign every track's `trackDom`'s `<svg>` element into its
    corresponding slot (`pinTop`, `pinBottom`, `scroll`, and
    `pinInBetween`) by inserting it into the corresponding DOM node.
*   Keep record of the relative order for every `<svg>` element within its
    own slot.
    Every track object will have an __`effective priority`__ value consists of
    its slot allocation (`pinTop`, `scroll`, `pinBottom`, `pinInBetween`)
    and its position within the slot.
*   Assign the `y` property for every `<svg>` when drawing the DOM element
    so that it appears in the correct order regardless of its order in the
    DOM tree.

#### Modifying the track list and its effect on track order

##### Adding new tracks

This action may only come from the parent element.

When a new track is being added to the visible list, it will be allocated to
its corresponding slot but __added to the very end of the list__. The
`effective priority` value of the new track will be set if not done yet.

##### Removing a track

This action may come from the parent element or from the `<chart-window>`
itself (via a "delete" button, to be implemented).

When an existing track is being removed, it will be delisted from the slot,
the `trackDom` object will be put into a recycled list (previous recycled list
will be cleared) and all the `visibility` values and `effective priority`
values will be updated accordingly.

If this action comes from the `<chart-window>` itself, notify its parent about
this change.

##### Restoring a track previously removed

This action may only come from the parent element.

When a restoring command was received, all `trackDom`s in the recycled list
will be restored to their corresponding location, their `track`'s `visibility`
properties and `effective priority` values will be adjusted. After that, the
recycled list will be cleared.

##### Changing the location of a track

This action may come from the parent element or from the `<chart-window>`
itself (via drag-drop, to be implemented).

The `effective priority` will be updated to the new locations if the action
comes from `<chart-window>` itself (this happens when user tries to alter the
order of the tracks).

Then the actual `svg` `y` values will be updated to reflect the new location.

If this action comes from the `<chart-window>` itself, notify its parent about
this change.

-->
<dom-module id="chart-window">
  <template>
    <style include="genemo-shared-styles">
      :host {
        position: relative;
        overflow-x: hidden;
        overflow-y: auto;
        font-family: 'Roboto', Arial, Helvetica, sans-serif;
        display: block;
        margin: 0;
        padding: 0;
        width: 100%;
        @apply --layout-vertical;
        @apply --layout-flex;
      }
      div {
        margin: 0;
        padding: 0;
      }
      div.pinnedParts {
        @apply --layout-start;
        overflow: hidden;
      }
      div.scrollingParts {
        @apply --layout-flex;
        overflow-x: hidden;
        overflow-y: auto;
      }
    </style>
    <style include="genemo-track-styles"></style>
    <div id="chartHolding" hidden$="[[!_initialized]]">
      <div class="pinnedParts" id="_PinTop">
        <div class="trackDomHolder"></div>
        <svg class="svgHolder" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        </svg>
      </div>
      <div class="scrollingParts" id="_Scroll">
        <svg class="svgHolder" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        </svg>
      </div>
      <div class="pinnedParts" id="_PinBottom">
        <svg class="svgHolder" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        </svg>
      </div>
      <div class="pinnedParts" id="_PinBetween">
        <svg class="svgHolder" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        </svg>
      </div>
    </div>
    <template is="dom-if" if="[[showTutorial]]">
      <tutorial-highlight id="coorTrackTutorial"
        tutorial-key="coor-track-tutorial"
        dom-target-id="[[_coorDomSvgId]]">
        <div>
          You may use mouse wheel within the coordinate track to zoom in/out, drag any track to move.
        </div>
      </tutorial-highlight>
    </template>
  </template>
  <script>
var GIVe = (function (give) {
  'use strict'

  class EffPrior {
    constructor (pinValue, pos) {
      // raise error if pinValue is not correct
      this.pinValue = pinValue
      this.pos = pos
    }

    set pinValue (newPinValue) {
      if (typeof this.constructor.pinValueMap[newPinValue] !== 'number') {
        throw new give.GiveError('Invalid pinValue: ' + newPinValue)
      }
      this._pinValue = newPinValue
    }

    get pinValue () {
      return this._pinValue
    }

    set pos (newPos) {
      if (!Number.isInteger(newPos) || newPos < 0) {
        throw new give.GiveError('Invalid new position number: ' + newPos)
      }
      this._pos = newPos
    }

    get pos () {
      return this._pos
    }

    static isValidEffPrior (effPrior) {
      return effPrior &&
        typeof this.pinValueMap[effPrior._pinValue] === 'number'
    }

    static compare (effPrior1, effPrior2) {
      // first handle null values (null is larger than any valid value)
      if (!this.isValidEffPrior(effPrior1) ||
        !this.isValidEffPrior(effPrior2)
      ) {
        return !this.isValidEffPrior(effPrior1)
          ? (!this.isValidEffPrior(effPrior2) ? 0 : 1) : -1
      }
      return effPrior1._pinValue === effPrior2._pinValue
        ? Math.sign(this.pinValueMap[effPrior1._pinValue] -
          this.pinValueMap[effPrior2._pinValue])
        : Math.sign(effPrior1._pos - effPrior2._pos)
    }
  }

  EffPrior.pinValueMap = {
    'top': -1,
    'scroll': 0,
    'bottom': 1,
    'inbetween': 2
  }

  give.EffPrior = EffPrior

  class ChartWindow extends Polymer.mixinBehaviors([
    Polymer.IronResizableBehavior,
    give.RefEmbeddedBehavior], Polymer.Element
  ) {
    constructor () {
      super()
      this.svgNS = 'http://www.w3.org/2000/svg'
      this.resizeDebounceInt = 400
      // this.resizeJobName = 'RESIZE'
      this.resizeAsyncProcess = null
      this._trackDoms = []
      this._hiddenTrackDoms = []
      this._addedTrackMap = new Map()
    }

    static get properties () {
      return {
        /**
         * The view windows to display in the element.
         * The members of the properties should be `GIVE.ChromRegion` Objects
         * @type {GIVe.ChromRegion}
         */
        _viewWindow: {
          type: Object,
          notify: true
        },

        index: {
          type: Number,
          value: 0
        },

        totalWindows: {
          type: Number,
          value: 1
        },

        _coorDomSvgId: {
          type: String,
          value: ''
        },

        /**
         * The view window to display in the element, in coordinate format.
         * This is for HTML attributes
         */
        coordinate: {
          type: String,
          notify: true
        },

        defaultTrackIdList: {
          type: Array,
          value: function () {
            return []
          }
        },

        _initialized: {
          type: Boolean,
          value: false
        },

        _trackGap: {
          type: Number,
          value: 0.3 // unit is em
        },

        _textSize: {
          type: Number,
          value: 12 // unit is px
        },

        textMargin: {
          type: Number,
          value: 100 // unit is px
        },

        _threshold: {
          type: Number,
          value: 0.0
        },

        /**
         * Promise resolved when the entire `chart-window` is ready
         * @type {object}
         */
        readyPromise: {
          type: Object,
          value: null
        },

        /**
         * Flag to indicate whether this is the first time this `chart-area`
         * element is run
         * @type {boolean}
         */
        _firstRun: {
          type: Boolean,
          value: true
        },

        showTutorial: {
          type: Boolean,
          value: false
        }
      }
    }

    ready () {
      super.ready()
      // initialize this._viewWindows from this.coordinates
      if (give.ChromRegion.isValidChromRegion(this.coordinate,
        this._refObj) &&
        (!this._viewWindow ||
          this._viewWindow.regionToString(false) !==
          new give.ChromRegion(this.coordinate, this._refObj)
            .regionToString(false)
        )
      ) {
        this._viewWindow = new give.ChromRegion(this.coordinate, this._refObj)
      } else {
        this._viewWindow = false
      }

      if (this.defaultTrackIdList.length > 0) {
        this._needOverrideDefault = true
      }

      this._initDOMCoorTrack()

      this._svgSizes = {
        '_PinTop': 0,
        '_Scroll': 0,
        '_PinBottom': 0,
        '_PinBetween': 0
      }

      this.addEventListener('iron-resize', this._onIronResize)
      this.addEventListener('track-ready', this._trackReadyHandler)
      this.addEventListener('update-window', this._updateWindowHandler)
    }

    attached () {
      this.async(function () {
        // attach all trackDoms
        this._checkVWindowsInit(true)
      })
    }

    _checkVWindowsInit () {
      if (!this._initialized) {
        if (this._refObj && this._viewWindow) {
          this._initialized = true
          this.resetDOM()
          return true
        } else {
          this._initialized = false
          return false
        }
      }
      return true
    }

    /**
     * Merge properties together
     * @todo Will be changed into `track-dom-behavior` or `basic-funcs`
     *
     * @param  {object} original - original object
     * @param  {object} newProp - object with new properties
     * @returns {object} object with the merged properties
     */
    _mergeProperty (original, newProp) {
      for (var key in newProp) {
        if (newProp.hasOwnProperty(key)) {
          original[key] = newProp[key]
        }
      }
      return original
    }

    _createTrackProp (props) {
      props = props || {}
      props.windowIndex = this.index
      props.width = this.$.chartHolding.clientWidth
      props.textMargin = this.textMargin
      return props
    }

    _getSlotId (track) {
      if (track.windowSpan > 1) {
        if (this.index + track.windowSpan > this.totalWindows) {
          return null
        }
        return '_PinBetween'
      } else {
        return this._slotIdFromPinValue(track.getSetting('pin'))
      }
    }

    _slotIdFromPinValue (pinValue) {
      pinValue = pinValue || ''
      let reverseDom =
        (this.index > 0 && this.index === this.totalWindows - 1)
      switch (pinValue.toLowerCase()) {
        case 'top':
          return reverseDom ? '_PinBottom' : '_PinTop'
        case 'bottom':
          return reverseDom ? '_PinTop' : '_PinBottom'
        case 'inbetween':
          return '_PinBetween'
        default:
          return '_Scroll'
      }
    }

    _pinValueFromSlotId (slotId) {
      let reverseDom =
        (this.index > 0 && this.index === this.totalWindows - 1)
      switch (slotId.toLowerCase()) {
        case '_PinTop':
          return reverseDom ? 'bottom' : 'top'
        case '_PinBottom':
          return reverseDom ? 'top' : 'bottom'
        case '_PinBetween':
          return 'inbetween'
        default:
          return 'scroll'
      }
    }

    _findEffPriorIndex (effPriority) {
      return give.locationOf(effPriority, this._trackDoms, null, null,
        (effPriority, dom2) => EffPrior.compare(
          effPriority, dom2.parent.effPriority
        ), true
      )
    }

    _addTrackDomSvg (trackDom, honorEffPriority) {
      if (trackDom && !this._addedTrackMap.has(trackDom.parent.id)) {
        let slotId
        if (honorEffPriority && trackDom.parent.effPriority) {
          slotId = this._slotIdFromPinValue(
            trackDom.parent.effPriority.pinValue
          )
        } else {
          slotId = this._getSlotId(trackDom.parent)
          if (!trackDom.parent.effPriority) {
            trackDom.parent.effPriority =
              new EffPrior(this._pinValueFromSlotId(slotId),
                this._svgSizes[slotId])
          }
        }
        // Add DOM element
        this.shadowRoot.querySelector('div#' + slotId + ' > svg.svgHolder')
          .appendChild(trackDom.TrackSvg)
        // Find the correct location of the new DOM
        let domPos = this._findEffPriorIndex(trackDom.parent.effPriority)
        if (this._trackDoms[domPos] &&
          !EffPrior.compare(this._trackDoms[domPos].parent.effPriority,
            trackDom.parent.effPriority)
        ) {
          // Update all effPriority values for DOMs after the new DOM
          for (let i = domPos;
            i < this._trackDoms.length &&
            this._trackDoms[i].parent.effPriority.pinValue ===
            trackDom.parent.effPriority.pinValue;
            i++
          ) {
            this._trackDoms[i].parent.effPriority.pos += 1
          }
        }
        // Insert the new DOM into its correct location
        this._trackDoms.splice(domPos, 0, trackDom)

        this._addedTrackMap.set(trackDom.parent.id, {
          'trackDom': trackDom,
          'visible': true
        })
        this._svgSizes[slotId]++
        return slotId
      }
      return null
    }

    _addVisibleTrack (track, props) {
      if (!this._addedTrackMap.has(track.id)) {
        try {
          let newTrackDom = track.createDomObj(this._createTrackProp(props))
          this._addTrackDomSvg(newTrackDom)
          return newTrackDom
        } catch (err) {
          give._verbConsole.warn(err)
          give.fireSignal('warning', { msg: err.message })
          return null
        }
      }
    }

    _addHiddenTrack (trackDom) {
      if (trackDom) {
        this._hiddenTrackDoms.push(trackDom)
        this._addedTrackMap.set(trackDom.parent.id, {
          'trackDom': trackDom,
          'visible': false
        })
      }
    }

    _removeTrack (tracks) {
      if (!Array.isArray) {
        tracks = [tracks]
      }
      let visibleTracksChanged = false
      tracks.forEach(track => {
        if (this._addedTrackMap.has(track.id)) {
          let trackDom = this._addedTrackMap.get(track.id).trackDom
          if (this._addedTrackMap.get(track.id).visible) {
            // This track is visible, remove the <svg> element from its slot
            this.shadowRoot.querySelector(
              'div#' + this._slotIdFromPinValue(track.effPriority.pinValue) +
              ' > svg.svgHolder'
            ).removeChild(trackDom.TrackSvg)
            // Then remove the DOM itself
            this._trackDoms = this._trackDoms.filter(dom => {
              return dom !== trackDom
            })
            // set flag to update effPriority values
            visibleTracksChanged = true
          } else {
            // This track is a linked track (some interaction track),
            // Remove DOM only
            this._hiddenTrackDoms = this._hiddenTrackDoms.filter(dom => {
              return dom !== trackDom
            })
          }
          this._addedTrackMap.delete(track.id)
        } else {
          give._verbConsole.warn('Track ID "' + track.id + '" does not exist!')
        }
      })

      if (visibleTracksChanged) {
        // Update all effPriority values affected
        for (let slotId in this._svgSizes) {
          if (this._svgSizes.hasOwnProperty(slotId)) {
            this._svgSizes[slotId] = 0
          }
        }
        this._trackDoms.forEach(trackDom => {
          let slotId = this._pinValueFromSlotId(
            trackDom.parent.effPriority.pinValue)
          trackDom.parent.effPriority.pos = this._svgSizes[slotId].length
          this._svgSizes[slotId]++
        })
      }
    }

    /**
     * _trackEffPriorUpdated - this is used when the `effPriority` values
     *    __has been updated for all `track`s__ in the parent element, and the
     *    DOM array order needs to be restored.
     *
     * @param  {TrackObjectBase} track - the track whose `effPriority` has
     *    changed
     */
    _trackEffPriorUpdated (track, oldIndex, newIndex) {
      if (track && this._addedTrackMap.has(track.id)) {
        throw new give.GiveError('Track does not exist for track "' +
          track && track.id + '"!')
      }
      if (this._addedTrackMap.get(track.id).visible) {
        let trackDom = this._addedTrackMap.get(track.id).trackDom
        let oldIndex = this._trackDoms.indexOf(trackDom)
        if (oldIndex >= 0) {
          this._moveTrackDom(oldIndex,
            this._findEffPriorIndex(trackDom.parent.effPriority))
        } else {
          throw new give.GiveError('TrackDOM does not exist for track "' +
            track.id + '"!')
        }
      }
    }

    _moveTrackDom (oldIndex, newIndex) {
      let trackDom = this._trackDoms[oldIndex]
      this._trackDoms.splice(oldIndex, 1)
      this._trackDoms.splice(
        this._findEffPriorIndex(trackDom.parent.effPriority), 0, trackDom)
    }

    /**
     * _changeTrackEffPrior - change the `effPriority` value of the `track`
     *    given the `trackDom`
     *
     * @param  {TrackDom} trackDom       The `trackDom` for which `effPriority`
     *    needs to be changed.
     * @param  {EffPrior} newEffPriority The new `effPriority` value.
     *    Notice that the `pos` value is the new position of the `trackDom`
     *    as if its just being inserted. Therefore, it __should not consider
     *    the position of `trackDom` itself__ if the new location is after
     *    the original one.
     */
    _changeTrackEffPrior (trackDom, newEffPriority) {
      if (trackDom && newEffPriority) {
        let oldEffPriority = trackDom.parent.effPriority
        if (EffPrior.compare(oldEffPriority, newEffPriority)) {
          // determine if the pin value has changed
          let oldIndex = this._trackDoms.indexOf(trackDom)
          let newIndex = this._findEffPriorIndex(newEffPriority)
          if (oldEffPriority.pinValue === newEffPriority.pinValue) {
            // same pin value, just change the tracks in between
            let step = Math.sign(newIndex - oldIndex)
            for (let i = oldIndex + step;
              i * step <= newIndex * step;
              i += step
            ) {
              this._trackDoms[i].parent.effPriority.pos -= step
            }
          } else {
            // pin value is different, separate into two steps
            // -1 for all tracks with the old pin value and pos > oldPos
            for (let i = oldIndex + 1;
              i < this._trackDoms.length &&
                this._trackDoms[i].parent.effPriority.pinValue ===
                  oldEffPriority.pinValue;
              i++
            ) {
              this._trackDoms[i].parent.effPriority.pos -= 1
            }
            // +1 for all tracks with the new pin value and pos >= newPos
            for (let i = newIndex;
              i < this._trackDoms.length &&
                this._trackDoms[i].parent.effPriority.pinValue ===
                  newEffPriority.pinValue;
              i++
            ) {
              this._trackDoms[i].parent.effPriority.pos += 1
            }
          }
          trackDom.parent.effPriority = newEffPriority
          this._moveTrackDom(oldIndex, newIndex)
        } else {
          give._verbConsole.warn('Effective priority not changed.')
        }
      } else {
        throw new give.GiveError('No TrackDOM or effPriority provided!')
      }
    }

    /**
     * Update the height and location of individual tracks
     *
     * @param  {number} width - Width of the current area
     */
    updateHeightLocation (changeWindow) {
      // calculate the heights for all tracks
      // note that by the time this is called, all tracks should be ready
      // (this is handled in track-ready event handler)
      // this will also rearrange the y value for all tracks as well
      give._verbConsole.info('UpdateHeightLocation(' + changeWindow + ')')
      if (!this._trackDomsByWindow.every(
        this._updateDomHeightInWindow.bind(this, changeWindow), this)
      ) {
        // resizing is needed for all the windows
        // note that new width is already stored in `this._svgWidth`
        this._trackDomsByWindow.forEach(
          this._updateDomHeightInWindow.bind(this, changeWindow), this)
      }
      if (changeWindow) {
        this.fire('update-coordinate', {
          newWindow: this.getViewWindowString()
        })
      }
      delete this.resizeAsyncProcess
    }

    /**
     * Refresh all tracks in the view
     */
    _updateTracks () {
      // index is the window index
      // only need to update tracks involved with that index
      if (typeof index === 'number') {
        this._updateTracksInWindow(index)
      } else {
        this._trackDomsByWindow.forEach(function (trackDoms, windex) {
          this._updateTracksInWindow(windex)
        }, this)
      }
    }

    /**
     * Refresh all tracks in a certain view
     *
     * @param  {number} index - The index for the view being updated
     */
    _updateTracksInWindow (index) {
      // index is the window index
      // only need to update tracks involved with that index
      this._readiness = false
      delete this._svgWidth
      this._callForeachFuncOnDomInWindowEntry(
        function (trackDom, trackDomIndex) {
          trackDom.updateTrack(this._viewWindows[index],
            index, this._threshold)
        }.bind(this), this._trackDomsByWindow[index], index)
    }

    _trackReadyHandler (e) {
      // check if all tracks are ready, otherwise do nothing
      if (this._trackDomsByWindow.every(
        this._callEveryOnDomInWindowEntry.bind(this, function (trackDom) {
          return trackDom.isReady
        }), this)
      ) {
        this.updateHeightLocation()
        try {
          if (this._firstRun && this.showTutorial &&
            this.coorTrackZeroDOM.getTrackSvg()
          ) {
            this.$.coorTrackTutorial.domTargetId =
              this.coorTrackZeroDOM.getTrackSvg().id
            this.$.coorTrackTutorial.showTutorial()
          }
          this._firstRun = false
        } catch (e) {
          give._verbConsole.warn(e)
          give.fireSignal('warning', { msg: e.message })
        } finally {
          this._readiness = true
        }
      }
    }

    /**
     * _changeViewWindowObj - Change the range of a sub view.
     *   The range should be a `GIVE.ChromRegion` object and clipped.
     *   No exceptions should be thrown from this function.
     *
     * @param  {ChromRegionLiteral} viewWindow - The target range
     * @param  {number} index - Index of the viewWindow.
     * @return {string} The actual range (may be cropped by reference),
     *                   converted to string.
     */
    _changeViewWindowObj (viewWindow) {
      this._viewWindow = viewWindow.clone()
      this.coordinate = viewWindow.regionToString(false)
      if (this._initialized) {
        this._updateTracks()
      } else {
        this._checkVWindowsInit()
      }
      return this.coordinate
    }

    /**
     * Change the range of a sub view.
     * Range may be cropped if it exceed the maximum range allowed by the reference.
     *
     * @param  {string|ChromRegionLiteral} viewWindow - The range to change into.
     * @param  {boolean} forceDomReset - Whether to force the DOM to reload.
     * @return {string} The actual range (may be cropped by reference),
     *                   converted to string.
     */
    changeViewWindow (viewWindow, forceDomReset) {
      if (forceDomReset) {
        this._initialized = false
      }
      try {
        // This may throw some exceptions
        // (when invalid view windows are supplied)
        var viewWindowObj = new give.ChromRegion(viewWindow, this._refObj)
      } catch (err) {
        // Invalid view windows are supplied, fail gracefully
        if (!this.passExceptions) {
          // TODO: gracefully handle the exception
        } else {
          err.data = err.data || {}
          err.data.updatedCoor =
            (this._viewWindow &&
              this._viewWindow.regionToString
            ) ? this._viewWindow.regionToString(false) : null
          throw err
        }
      }
      return this._changeViewWindowObj(viewWindowObj)
    }

    _changeThreshold (_threshold) {
      this._threshold = _threshold || this._threshold
      this._trackDomsByWindow.forEach(
        this._callForeachFuncOnDomInWindowEntry.bind(
          function (trackDom, index) {
            if (trackDom.updateThreshold) {
            // is an interaction track
              trackDom.updateThreshold(this._threshold)
            }
          }.bind(this)
        ), this
      )
    }

    refreshAll (viewWindows, threshold) {
      if (typeof (threshold) !== 'undefined' && threshold !== null && !viewWindows) {
        // only update _threshold only
        this._changeThreshold(threshold)
        return this.getViewWindowString()
      } else {
        this._threshold = (typeof (threshold) !== 'undefined' && threshold !== null ? threshold : this._threshold)
        if (viewWindows) {
          this.changeAllViewWindows(viewWindows)
        } else {
          this._updateTracks()
        }
      }
      return this.getViewWindowString()
    }

    /**
     * Get the `string` of ranges in all views
     *
     * @returns {Array<string>} The ranges, converted to `string`.
     */
    getViewWindowString () {
      return this._viewWindows.map(function (vwindow, index) {
        return vwindow.regionToString(false)
      }, this)
    }

    /**
     * _overrideTrackDefaultVis - Override default shown tracks
     */
    _overrideTrackDefaultVis () {
      if (this._refObj && this.defaultTrackIdList.length > 0) {
        this._refObj.setTrackSettings('visibility', false, null)
        this.defaultTrackIdList.forEach(function (id) {
          try {
            this._refObj.tracks.get(id).setSetting('visibility', true)
          } catch (e) {
            give._verbConsole.warn('Track `' + id + '` does not exist!\n' + e)
            give.fireSignal('warning',
              { msg: 'Track `' + id + '` does not exist!' })
          }
        }, this)
      }
      delete this._needOverrideDefault
    }

    /**
     * _numOfSubsChanged - sync number of viewWindows to `numOfSubs`
     *
     * @param  {number} newValue new `numOfSubs` value
     * @param  {number} oldValue old `numOfSubs` value
     */
    _numOfSubsChanged (newValue, oldValue) {
      this._initialized = false
      if (this._refObj) {
        var defaultWindows = this._refObj.settings.defaultViewWindows
        for (var i = 0; i < newValue; i++) {
          if (this.coordinates[i] !== false &&
            !give.ChromRegion.isValidChromRegion(this.coordinates[i],
              this._refObj
            ) && Array.isArray(this._refObj.settings.defaultViewWindows)
          ) {
            this.splice('coordinates', i, 1,
              defaultWindows[i % defaultWindows.length])
          }
          if (give.ChromRegion.isValidChromRegion(this.coordinates[i],
            this._refObj)
          ) {
            this.splice('_viewWindows', i, 1,
              new give.ChromRegion(this.coordinates[i], this._refObj))
          } else {
            this.splice('_viewWindows', i, 1, null)
          }
        }
        this._checkVWindowsInit()
      }
    }

    _setRefObj (refObj) {
      this._refObj = refObj
      this._numOfSubsChanged(this.numOfSubs)
      this._initialized = false
      this._checkVWindowsInit()
    }

    _initDOMCoorTrack () {
      if (this._refObj) {
        let coorTrack = give.TrackObject.createTrack(
          'coor_' + this._refObj.db,
          this._createTrackProp({ type: 'coordinate', priority: 0 }),
          this._refObj
        )
        coorTrack.effPriority = this.constructor.COOR_TRACK_EFF_PRIORITY
        this._coorDomSvgId = this._addVisibleTrack(coorTrack).trackSvg.id
      }
    }

    /**
     * Reset the entire DOM display
     */
    resetDOM () {
      if (this._initialized) {
        this._readiness = false
        this.addAllTrackDoms()
      } else {
        this._readiness = true
      }
    }

    _clearDOM () {
      var svgList = Polymer.dom(this.$.chartHolding).querySelectorAll('svg.svgHolder')
      svgList.forEach(function (svgElem, index) {
        while (Polymer.dom(svgElem).firstChild) {
          Polymer.dom(svgElem).removeChild(Polymer.dom(svgElem).firstChild)
        }
      }, this)
      while (Polymer.dom(this.$.trackDomHolder).firstChild) {
        Polymer.dom(this.$.trackDomHolder).removeChild(Polymer.dom(this.$.trackDomHolder).firstChild)
      }
    }

    _addAllTrackDomsTracksReady (noRefreshContent, refObj) {
      // function called when tracks are ready for this._refObj
      if (refObj.db === this.ref) {
        // Only respond to this call if ref has not been changed
        if (!this._needOverrideDefault) {
          // no default tracks supplied, use groupIdList filter and
          // visibility settings
          // sort by priorities defined in database
          if (this.groupIdList && this.groupIdList.length > 0) {
            this.groupIdList.forEach(groupID => {
              if (this._refObj.groups.hasOwnProperty(groupID)) {
                this._refObj.groups[groupID].forEach(showTrack)
              }
            })
          } else {
            this._refObj.tracks.forEach(showTrack)
          }
        } else {
          // use this.defaultTrackIdList to directly fill in the DOM array
          // without sorting by priority (use the defaultTrackIdList order)
          // then populate SVG
          this._overrideTrackDefaultVis()
        }
        let showTrack = (track, index) => {
          // notice that if track type is 'interaction',
          // it needs to be 'unshifted' to later windows
          if (track.getSetting('visibility') >
            give.TrackObject.StatusEnum.VIS_NONE
          ) {
            this._trackDoms.push(track.createDomObj(
              this._createTrackProp({ subPriority: index })
            ))
          }
        }
        if (this.groupIdList && this.groupIdList.length > 0) {
          this.groupIdList.forEach(groupID => {
            if (this._refObj.groups.hasOwnProperty(groupID)) {
              this._refObj.groups[groupID].forEach(showTrack)
            }
          })
        } else {
          this._refObj.tracks.forEach(showTrack)
        }
        // sort trackDomBy priorities
        this._trackDoms.sort(
          (a, b) => give.comparePriorities(a.Priorities, b.Priorities))
        this.populateDOM(noRefreshContent)
      }
    }

    addAllTrackDoms (noRefreshContent) {
      this._refObj.initTracks().then(
        refObj => this._addAllTrackDomsTracksReady(noRefreshContent, refObj))
    }

    _removeInvisibleTrackDoms () {
      this._trackDomsByWindow.forEach(function (domInWindowEntry, windowIndex) {
        // notice that because tracks may get deleted, don't use forEach with splice
        for (var key in domInWindowEntry) {
          if (domInWindowEntry.hasOwnProperty(key) &&
            Array.isArray(domInWindowEntry[key])
          ) {
            // filter out all tracks with visibility set as 0
            // delete entries in domInWindowEntry.map first
            for (var i = 0; i < domInWindowEntry[key].length; i++) {
              if (domInWindowEntry[key][i].getTrackSetting('visibility') ===
                give.TrackObject.StatusEnum.VIS_NONE) {
                delete domInWindowEntry.map[domInWindowEntry[key][i].parent.id]
                domInWindowEntry[key].splice(i, 1)
                i--
              }
            }
          }
        }
      }, this)
    }

    _setDivElemInWindow (domInWindowEntry, index) {
      var reverse = (index > 0 && index === this._trackDomsByWindow.length - 1)
      if (
        !this.$$('#' + this._getElemId(domInWindowEntry.divId, 'Scroll'))
      ) {
        return false
      }
      domInWindowEntry.pinAbove.divElem = this.$$('#' +
        this._getElemId(domInWindowEntry.divId, reverse ? 'PinBottom' : 'PinTop'))
      domInWindowEntry.scrolling.divElem = this.$$('#' +
        this._getElemId(domInWindowEntry.divId, 'Scroll'))
      domInWindowEntry.pinBelow.divElem = this.$$('#' +
        this._getElemId(domInWindowEntry.divId, reverse ? 'PinTop' : 'PinBottom'))
      if (domInWindowEntry.pinInBetween) {
        domInWindowEntry.pinInBetween.divElem = this.$$('#' +
          this._getElemId(domInWindowEntry.divId, 'PinBetween'))
      }
      return true
    }

    _callForeachWithElemFuncOnDomInWindowEntry (func, startFunc, endFunc, domInWindowEntry, index) {
      var reverse = (index > 0 && index === this._trackDomsByWindow.length - 1)
      for (var key in domInWindowEntry) {
        if (domInWindowEntry.hasOwnProperty(key) &&
          Array.isArray(domInWindowEntry[key]) &&
          domInWindowEntry[key].divElem &&
          domInWindowEntry[key].divElem.querySelector('svg')
        ) {
          if (startFunc && typeof startFunc === 'function') {
            startFunc(domInWindowEntry[key].divElem)
          }
          var enumArray = reverse ? domInWindowEntry[key].slice().reverse()
            : domInWindowEntry[key]
          enumArray.forEach(func.bind(this,
            domInWindowEntry[key].divElem), this)
          if (endFunc && typeof endFunc === 'function') {
            endFunc(domInWindowEntry[key].divElem)
          }
        }
      }
    }

    _callForeachFuncOnDomInWindowEntry (func, domInWindowEntry, index) {
      var reverse = (index > 0 && index === this._trackDomsByWindow.length - 1)
      for (var key in domInWindowEntry) {
        if (domInWindowEntry.hasOwnProperty(key) &&
          Array.isArray(domInWindowEntry[key])
        ) {
          var enumArray = reverse ? domInWindowEntry[key].slice().reverse()
            : domInWindowEntry[key]
          enumArray.forEach(func, this)
        }
      }
    }

    _callEveryOnDomInWindowEntry (func, domInWindowEntry, index) {
      // same thing as _callForeachFuncOnDomInWindowEntry, just replace forEach by every
      var reverse = (index > 0 && index === this._trackDomsByWindow.length - 1)
      for (var key in domInWindowEntry) {
        if (domInWindowEntry.hasOwnProperty(key) &&
          Array.isArray(domInWindowEntry[key])
        ) {
          var enumArray = reverse ? domInWindowEntry[key].slice().reverse()
            : domInWindowEntry[key]
          if (!enumArray.every(func, this)) {
            return false
          }
        }
      }
      return true
    }

    _populateDomInWindow (domInWindowEntry, index) {
      var _populateDomInComponent = function (component, trackDom, trackDomIndex) {
        Polymer.dom(this.$.trackDomHolder).appendChild(trackDom)
        Polymer.dom(component.querySelector('svg.svgHolder')).appendChild(trackDom.getTrackSvg())
      }
      this._callForeachWithElemFuncOnDomInWindowEntry(
        _populateDomInComponent.bind(this), null, null,
        domInWindowEntry, index)
    }

    /**
     * _updateDomHeightInWindow - Update the heights of DOMs in any viewWindow
     *
     * @param  {boolean} changeWindow - index of domInWindowEntry in the array
     * @param  {[
     *   pinAbove: Array.<GIVe.TrackDomBehavior>,
     *   scrolling: Array.<GIVe.TrackDomBehavior>,
     *   pinBelow: Array.<GIVe.TrackDomBehavior>,
     *   map: Object,
     *   [pinInBetween: Array.<GIVe.TrackDomBehavior>]
     * ]} domInWindowEntry - viewWindow Array
     * @param  {number} index - index of domInWindowEntry in the array
     */
    _updateDomHeightInWindow (changeWindow, domInWindowEntry, index) {
      var _prepareSvgHeight = function (svgWidth, divElem) {
        divElem._currY = 0
        divElem._svgWidth = svgWidth || divElem.clientWidth
      }
      var _setDomIndHeight = function (divElem, trackDom, index) {
        trackDom.updateLocationSize(0, divElem._currY, divElem._svgWidth, null, null, changeWindow ? null : false)
        divElem._currY += trackDom.getHeight() + this._trackGap * this._textSize
      }.bind(this)
      var _setSvgWidthHeight = function (divElem) {
        if (divElem._currY > 0) {
          divElem._currY -= this._trackGap * this._textSize
        }
        Polymer.dom(divElem).querySelector('svg.svgHolder').setAttribute('width', divElem._svgWidth)
        Polymer.dom(divElem).querySelector('svg.svgHolder').setAttribute('height', divElem._currY)
        Polymer.dom(divElem).querySelector('svg.svgHolder').setAttribute('viewBox',
          '0 0 ' + divElem._svgWidth + ' ' + divElem._currY)
        delete divElem._currY
        delete divElem._svgWidth
      }.bind(this)
      this._callForeachWithElemFuncOnDomInWindowEntry(_setDomIndHeight,
        _prepareSvgHeight.bind(this, this._svgWidth),
        _setSvgWidthHeight, domInWindowEntry, index)
      this._svgWidth = this._svgWidth ||
        domInWindowEntry.scrolling.divElem.clientWidth
      if (this._svgWidth > domInWindowEntry.scrolling.divElem.clientWidth) {
        this._svgWidth = domInWindowEntry.scrolling.divElem.clientWidth
      }
      if (this._svgWidth !== domInWindowEntry.pinAbove.divElem.clientWidth) {
        // scrolling happened, needs to shrink pinned track width
        return false
      }
      return true
    }

    populateDOM (noRefreshContent) {
      // first clear old DOMs
      this._clearDOM()
      // then populate all new DOMS by window
      this._trackDomsByWindow.forEach(this._populateDomInWindow, this)
      this.updateHeightLocation()
      Polymer.dom.flush()
      if (!noRefreshContent) {
        // then update everything
        this.refreshAll()
      }
    }

    updateDOM (noRefreshContent) {
      // update existing DOMs, first remove all tracks that should be hidden
      // if noRefreshContent = true, do not refresh content (should be refreshed later)
      if (this._trackDomsByWindow && this._trackDomsByWindow.length > 0) {
        this._removeInvisibleTrackDoms()
      }

      // then add new Tracks (if not there already)
      this.addAllTrackDoms(noRefreshContent)
    }

    _updateWindowHandler (e) {
      // update the windows by events bubbled up from bottom tracks
      try {
        if (e.detail.newWindow instanceof give.ChromRegion ||
          typeof e.detail.newWindow === 'string'
        ) {
          this.changeViewWindow(e.detail.newWindow, !!(e.detail.tracks))
          this.fire('update-coordinate', {
            windowIndex: this.index,
            newWindow: e.detail.newWindow
          })
        }
      } catch (err) {
        give._verbConsole.warn(err)
      }
    }

    updateWindow (e) {
      this._updateWindowHandler(e)
    }

    _onIronResize (e, detail) {
      if (this._domsReady && this._trackDomsByWindow.every(
        this._callEveryOnDomInWindowEntry.bind(this, function (trackDom) {
          return trackDom.isReady
        }), this)
      ) {
        give._verbConsole.info('_onIronResize()')
        if (!this.resizeAsyncProcess) {
          delete this._svgWidth
          this.resizeAsyncProcess = this.async(
            this.updateHeightLocation.bind(this, false),
            this.resizeDebounceInt
          )
        }
      }
    }

  // TODO: add/remove/rearrange tracks

  }

  ChartWindow.svgNS = 'http://www.w3.org/2000/svg'

  ChartWindow.DOM_CHANGE_JOBNAME = 'DOMChange'
  ChartWindow.DOM_CHANGE_DEBOUNCE = 200

  ChartWindow.COOR_TRACK_EFF_PRIORITY = -1

  give.ChartWindow = ChartWindow
  window.customElements.define('chart-window', give.ChartWindow)

  return give
})(GIVe || {})

  </script>
</dom-module>
