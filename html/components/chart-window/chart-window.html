<!--
@license
Copyright 2017 GIVe Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../basic-func/basic-func.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../track-object/tracks-header.html">
<link rel="import" href="../ref-embedded-behavior/ref-embedded-behavior.html">
<link rel="import" href="../tutorial-highlight/tutorial-highlight.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../genemo-styles.html">
<link rel="import" href="genemo-track-styles.html">
<link href="https://fonts.googleapis.com/css?family=Roboto:500,400italic,700italic,700,400" rel="stylesheet" type="text/css">
<!--
### Overview

`<chart-area>` provides a Web Component element to interactively display genomic
data.

```html
<chart-area group-id-list='["genes", "singleCell"]' ref="mm10"></chart-area>
```

Although `<chart-area>` does not contain the navigational control elements as in `<chart-controller>`, users may still navigate by dragging and mouse-wheeling on the coordinates to move around.

Please refer to [`GIVe.RefEmbeddedBehavior`](../ref-embedded-behavior/index.html) for details on references used.

-->
<dom-module id="chart-window">
  <template>
    <style include="genemo-shared-styles">
      :host {
        position: relative;
        overflow-x: hidden;
        overflow-y: auto;
        font-family: 'Roboto', Arial, Helvetica, sans-serif;
        display: block;
        margin: 0;
        padding: 0;
        width: 100%;
        @apply --layout-vertical;
        @apply --layout-flex;
      }
      div {
        margin: 0;
        padding: 0;
      }
      div.pinnedParts {
        @apply --layout-start;
        overflow: hidden;
      }
      div.scrollingParts {
        @apply --layout-flex;
        overflow-x: hidden;
        overflow-y: auto;
      }
    </style>
    <style include="genemo-track-styles"></style>
    <div id="chartHolding" hidden$="[[!_initialized]]">
      <div class="pinnedParts" id="_PinTop">
        <div class="trackDomHolder"></div>
        <svg class="containedSvg" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        </svg>
      </div>
      <div class="scrollingParts" id="_Scroll">
        <svg class="containedSvg" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        </svg>
      </div>
      <div class="pinnedParts" id="_PinBottom">
        <svg class="containedSvg" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        </svg>
      </div>
      <div class="pinnedParts" id="_PinBetween">
        <svg class="containedSvg" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        </svg>
      </div>
    </div>
    <template is="dom-if" if="[[showTutorial]]">
      <tutorial-highlight id="coorTrackTutorial" tutorial-key="coor-track-tutorial">
        <div>
          You may use mouse wheel within the coordinate track to zoom in/out, drag any track to move.
        </div>
      </tutorial-highlight>
    </template>
  </template>
  <script>
var GIVe = (function (give) {
  'use strict'

  class ChartWindow extends Polymer.mixinBehaviors([
    Polymer.IronResizableBehavior,
    give.RefEmbeddedBehavior], Polymer.Element
  ) {
    constructor () {
      super()

    }

    static get properties () {
      return {
        /**
         * The view windows to display in the element.
         * The members of the properties should be `GIVE.ChromRegion` Objects
         * @type {Array.<GIVe.ChromRegion>}
         */
        _viewWindow: {
          type: Object,
          notify: true,
        },

        index: {
          type: Number,
          value: 0
        },

        totalWindows: {
          type: Number,
          value: 1
        },

        _trackDomHolder: {
          type: Array,
          value: function () {
            return []
          }
        },

        _hiddenTrackDomHolder: {
          type: Array,
          value: function () {
            return []
          }
        },

        _addedSvgOrderMap: {
          type: Object,
          value: function () {
            return {}
          }
        },

        _svgSizes: {
          type: Object,
          value: function () {
            return {
              '_PinTop': 0,
              '_Scroll': 0,
              '_PinBottom': 0,
              '_PinBetween': 0
            }
          }
        }

        /**
         * The array holding trackDoms for every view window.
         * The member of the array should be Objects with the following properties:
         * * `pinAbove`: An array of track DOMs that will be pinned at the top of the view window;
         * * `scrolling`: An array of track DOMs that will appear in the scrolling part;
         * * `pinBelow`: An array of track DOMs that will be pinned at the bottom of the view window;
         * * `pinInBetween`: *(optional)* An array of track DOMs that will appear in the space between
         *                    this view window and the next one;
         * * `map`: An Object used for id-to-DOM lookups;
         * * `hiddenTrackComponents`: An array of track DOMs that are hidden and never displayed;
         *                            (this is mainly used for cross-view-window tracks because
         *                             it will only display once but will receive update signal
         *                             from multiple views)
         * * `divId`: The id of the `<div>` tag for the view window.
         * Please refer to `this._initDOMArray()` for details.
         * @type {Array.<{
         *   pinAbove: Array.<GIVe.TrackDomBehavior>,
         *   scrolling: Array.<GIVe.TrackDomBehavior>,
         *   pinBelow: Array.<GIVe.TrackDomBehavior>,
         *   map: Object,
         *   [pinInBetween: Array.<GIVe.TrackDomBehavior>]
         * }>}
         */
        _trackDomsByWindow: {
          type: Array,
          value: function () {
            return []
          }
        },

        /**
         * The view windows to display in the element, in coordinate format.
         * This is for HTML attributes
         * @type {Array.<string>}
         */
        coordinate: {
          type: String,
          notify: true
        },

        _initialized: {
          type: Boolean,
          value: false
        },

        _trackGap: {
          type: Number,
          value: 0.3 // unit is em
        },

        _textSize: {
          type: Number,
          value: 12 // unit is px
        },

        textMargin: {
          type: Number,
          value: 100 // unit is px
        },

        _threshold: {
          type: Number,
          value: 0.0
        },

        /**
         * Promise resolved when the entire `chart-window` is ready
         * @type {object}
         */
        readyPromise: {
          type: Object,
          value: null
        },

        /**
         * Flag to indicate whether this is the first time this `chart-area`
         * element is run
         * @type {boolean}
         */
        _firstRun: {
          type: Boolean,
          value: true
        },

        showTutorial: {
          type: Boolean,
          value: false
        }
      }
    }

    listeners: {
      'track-ready': '_trackReadyHandler',
      'update-window': '_updateWindowHandler',
      'iron-resize': '_onIronResize',
      'dom-change': '_domChangeHandler'
    },

    created: function () {
      this.svgNS = 'http://www.w3.org/2000/svg'
      this.resizeDebounceInt = 400
      // this.resizeJobName = 'RESIZE'
      this.resizeAsyncProcess = null
    },

    ready: function () {
      // initialize this._viewWindows from this.coordinates
      this.coordinates.forEach(function (coordinateStr, index) {
        if (give.ChromRegion.isValidChromRegion(coordinateStr,
          this._refObj) &&
          (!this._viewWindows[index] ||
            this._viewWindows[index].regionToString(false) !==
            new give.ChromRegion(coordinateStr, this._refObj)
              .regionToString(false)
          )
        ) {
          this.splice('_viewWindows', index, 1,
            new give.ChromRegion(coordinateStr, this._refObj))
        } else {
          this.splice('_viewWindows', index, 1, false)
        }
      }, this)

      if (this.defaultTrackIdList.length > 0) {
        this._needOverrideDefault = true
      }
      // initialize DOM array
      this._initDOMArray()
    },

    attached: function () {
      this.async(function () {
        // attach all trackDoms
        this._checkVWindowsInit(true)
      })
    },

    _checkVWindowsInit: function () {
      if (!this._initialized) {
        if (this._refObj && this._viewWindows.every(function (vwindow) {
          return !!vwindow
        }, this)) {
          this._initialized = true
          this.resetDOM()
          return true
        } else {
          this._initialized = false
          return false
        }
      }
      return true
    },

    /**
     * Merge properties together
     * @todo Will be changed into `track-dom-behavior` or `basic-funcs`
     *
     * @param  {object} original - original object
     * @param  {object} newProp - object with new properties
     * @returns {object} object with the merged properties
     */
    _mergeProperty: function (original, newProp) {
      for (var key in newProp) {
        if (newProp.hasOwnProperty(key)) {
          original[key] = newProp[key]
        }
      }
      return original
    },

    _createTrackProp: function (viewWindowIndex, props) {
      props = props || {}
      props.windowIndex = viewWindowIndex
      props.width = this.$.chartHolding.clientWidth
      props.textMargin = this.textMargin
      return props
    },

    _getSlotId: function (trackDom) {
      let slotId = '_Scroll'
      let reverseDom =
        (this.index > 0 && this.index === this.totalWindows - 1)
      if (trackDom.parent.windowSpan > 1) {
        if (this.index + trackDom.parent.windowSpan > this.totalWindows) {
          return null
        }
        slotId = '_PinBetween'
      } else {
        if (trackDom.pin === 'top') {
          slotId = reverseDom ? '_PinBottom' : '_PinTop'
        } else if (trackDom.pin === 'bottom') {
          slotId = reverseDom ? '_PinTop': '_PinBottom'
        }
      }
      return slotId
    }

    _addTrackDomSvg: function (trackDom) {
      if (!this._addedSvgOrderMap.hasOwnProperty(trackDom.parent.getID()) {
        let slotId = this._getSlotId(trackDom)
        if (slotId) {
          this.shadowRoot.querySelector('div#' + slotId + ' > svg.containedSvg')
            .appendChild(trackDom.TrackSvg)
          this._addedSvgOrderMap[trackDom.parent.getID()]
            = this._svgSizes[slotId]
          this._svgSizes[slotId]++
        }
        return slotId
      }
      return null
    },

    _pushSingleWindowTrackDom: function (trackDom, viewWindowIndex) {
      var holder
      if (trackDom.pin === 'top') {
        holder = this._trackDomsByWindow[viewWindowIndex].pinAbove
      } else if (trackDom.pin === 'bottom') {
        holder = this._trackDomsByWindow[viewWindowIndex].pinBelow
      } else {
        holder = this._trackDomsByWindow[viewWindowIndex].scrolling
      }
      holder.splice(
        give.locationOf(trackDom, holder, null, null,
          function (trackDom1, trackDom2) {
            return give.TrackObject.comparePriorities(trackDom1.parent,
              trackDom2.parent, this._refObj.groups)
          }.bind(this)
        ) + 1, 0, trackDom)
    },

    _addMultiWindowTrackDom: function (trackDom, viewWindowIndex) {
      // actually this will enum all viewWindowIndices
      this._trackDomsByWindow[viewWindowIndex].pinInBetween.push(trackDom)
      for (var i = 1; i < trackDom.parent.windowSpan; i++) {
        this._trackDomsByWindow[viewWindowIndex + i]
          .hiddenTrackComponents.push(trackDom)
      }
    },

    _addVisibleTrack: function (track, viewWindowIndex, forceAdd, props) {
      if (forceAdd || (
        !this._trackDomsByWindow[viewWindowIndex].map
          .hasOwnProperty(track.getID()) &&
        viewWindowIndex + track.windowSpan <= this._viewWindows.length
      )) {
        try {
          let newTrackDom = new track._DomObjCtor(track)
          if (newTrackDom) {
            this._addTrackDom(newTrackDom, viewWindowIndex)
          }
          return newTrackDom
        } catch (err) {
          give._verbConsole.warn(err)
          give.fireSignal('warning', { msg: err.message })
          return null
        }
      }
    },

    /**
     * Update the height and location of individual tracks
     *
     * @param  {number} width - Width of the current area
     */
    updateHeightLocation: function (changeWindow) {
      // calculate the heights for all tracks
      // note that by the time this is called, all tracks should be ready
      // (this is handled in track-ready event handler)
      // this will also rearrange the y value for all tracks as well
      give._verbConsole.info('UpdateHeightLocation(' + changeWindow + ')')
      if (!this._trackDomsByWindow.every(
        this._updateDomHeightInWindow.bind(this, changeWindow), this)
      ) {
        // resizing is needed for all the windows
        // note that new width is already stored in `this._svgWidth`
        this._trackDomsByWindow.forEach(
          this._updateDomHeightInWindow.bind(this, changeWindow), this)
      }
      if (changeWindow) {
        this.fire('update-coordinate', {
          newWindow: this.getViewWindowStrings()
        })
      }
      delete this.resizeAsyncProcess
    },

    /**
     * Refresh all tracks in a certain view or all views
     *
     * @param  {number|null} index - The index for the view being updated, use null for all views
     */
    _updateTracks: function (index) {
      // index is the window index
      // only need to update tracks involved with that index
      if (typeof index === 'number') {
        this._updateTracksInWindow(index)
      } else {
        this._trackDomsByWindow.forEach(function (trackDoms, windex) {
          this._updateTracksInWindow(windex)
        }, this)
      }
    },

    /**
     * Refresh all tracks in a certain view
     *
     * @param  {number} index - The index for the view being updated
     */
    _updateTracksInWindow: function (index) {
      // index is the window index
      // only need to update tracks involved with that index
      this._readiness = false
      delete this._svgWidth
      this._callForeachFuncOnDomInWindowEntry(
        function (trackDom, trackDomIndex) {
          trackDom.updateTrack(this._viewWindows[index],
            index, this._threshold)
        }.bind(this), this._trackDomsByWindow[index], index)
    },

    _trackReadyHandler: function (e) {
      // check if all tracks are ready, otherwise do nothing
      if (this._trackDomsByWindow.every(
        this._callEveryOnDomInWindowEntry.bind(this, function (trackDom) {
          return trackDom.isReady
        }), this)
      ) {
        this.updateHeightLocation()
        try {
          if (this._firstRun && this.coorTrackZeroDOM &&
            this.coorTrackZeroDOM.getTrackSvg()
          ) {
            this.$.coorTrackTutorial.domTargetId =
              this.coorTrackZeroDOM.getTrackSvg().id
            this.$.coorTrackTutorial.showTutorial()
          }
          this._firstRun = false
        } catch (e) {
          give._verbConsole.warn(e)
          give.fireSignal('warning', { msg: e.message })
        } finally {
          this._readiness = true
        }
      }
    },

    /**
     * _changeViewWindowObj - Change the range of a sub view.
     *   The range should be a `GIVE.ChromRegion` object and clipped.
     *   No exceptions should be thrown from this function.
     *
     * @param  {ChromRegionLiteral} viewWindow - The target range
     * @param  {number} index - Index of the viewWindow.
     * @return {string} The actual range (may be cropped by reference),
     *                   converted to string.
     */
    _changeViewWindowObj: function (viewWindow, index) {
      this.splice('_viewWindows', index, 1, viewWindow.clone())
      this.splice('coordinates', index, 1,
        this._viewWindows[index].regionToString(false))
      if (this._initialized) {
        this._updateTracksInWindow(index)
      } else {
        this._checkVWindowsInit()
      }
      return this._viewWindows[index].regionToString(false)
    },

    /**
     * Change the range of a sub view.
     * Range may be cropped if it exceed the maximum range allowed by the reference.
     *
     * @param  {string|ChromRegionLiteral} viewWindow - The range to change into.
     * @param  {number} index - Index of the viewWindow.
     * @param  {boolean} forceDomReset - Whether to force the DOM to reload.
     * @return {string} The actual range (may be cropped by reference),
     *                   converted to string.
     */
    changeViewWindow: function (viewWindow, index, forceDomReset) {
      if (forceDomReset) {
        this._initialized = false
      }
      try {
        // This may throw some exceptions
        // (when invalid view windows are supplied)
        var viewWindowObj = new give.ChromRegion(viewWindow, this._refObj)
      } catch (err) {
        // Invalid view windows are supplied, fail gracefully
        if (!this.passExceptions) {
          // TODO: gracefully handle the exception
        } else {
          err.data = err.data || {}
          err.data.updatedCoor =
            (this._viewWindows[index] &&
              this._viewWindows[index].regionToString
            ) ? this._viewWindows[index].regionToString(false) : null
          throw err
        }
      }
      return this._changeViewWindowObj(viewWindowObj, index)
    },

    /**
     * Change ranges in all views at once
     *
     * @param  {Array<string|GIVe.ChromObject>} viewWindows The ranges.
     * @return {Array<string>} The actual ranges, converted to `string`.
     */
    changeAllViewWindows: function (viewWindows) {
      var exceptionList = []
      var viewWindowObjs = viewWindows.map(function (vWindow, index) {
        var vWindowObj = null
        try {
          vWindowObj = new give.ChromRegion(vWindow, this._refObj)
        } catch (err) {
          exceptionList.push(index, err)
        }
        return vWindowObj
      }, this)
      if (exceptionList.length > 0) {
        // some exception has happended during the conversion
        // throw an exception telling calling procedures
        if (this.passExceptions) {
          var error = new give.GiveError('Exception occured during' +
            ' ChromRegion conversion.')
          error.data = error.data || {}
          error.data.exceptionList = exceptionList
          error.data.updatedCoors = viewWindowObjs.map(
            function (vWindowObj) {
              return ((vWindowObj && vWindowObj.regionToString)
                ? vWindowObj.regionToString(false) : null)
            }
          )
          throw error
        } else {
          // TODO: gracefully handle the exception
        }
      } else {
        viewWindowObjs.forEach(function (vwindow, index) {
          this._changeViewWindowObj(vwindow, index)
        }, this)
      }
      return this.getViewWindowStrings()
    },

    _changeThreshold: function (_threshold) {
      this._threshold = _threshold || this._threshold
      this._trackDomsByWindow.forEach(
        this._callForeachFuncOnDomInWindowEntry.bind(
          function (trackDom, index) {
            if (trackDom.updateThreshold) {
            // is an interaction track
              trackDom.updateThreshold(this._threshold)
            }
          }.bind(this)
        ), this
      )
    },

    refreshAll: function (viewWindows, threshold) {
      if (typeof (threshold) !== 'undefined' && threshold !== null && !viewWindows) {
        // only update _threshold only
        this._changeThreshold(threshold)
        return this.getViewWindowStrings()
      } else {
        this._threshold = (typeof (threshold) !== 'undefined' && threshold !== null ? threshold : this._threshold)
        if (viewWindows) {
          this.changeAllViewWindows(viewWindows)
        } else {
          this._updateTracks()
        }
      }
      return this.getViewWindowStrings()
    },

    /**
     * Get the `string` of ranges in all views
     *
     * @returns {Array<string>} The ranges, converted to `string`.
     */
    getViewWindowStrings: function () {
      return this._viewWindows.map(function (vwindow, index) {
        return vwindow.regionToString(false)
      }, this)
    },

    /**
     * _overrideTrackDefaultVis - Override default shown tracks
     */
    _overrideTrackDefaultVis: function () {
      if (this._refObj && this.defaultTrackIdList.length > 0) {
        this._refObj.setTrackSettings('visibility', false, null)
        this.defaultTrackIdList.forEach(function (id) {
          try {
            this._refObj.tracks.get(id).setSetting('visibility', true)
          } catch (e) {
            give._verbConsole.warn('Track `' + id + '` does not exist!\n' + e)
            give.fireSignal('warning',
              { msg: 'Track `' + id + '` does not exist!' })
          }
        }, this)
      }
      delete this._needOverrideDefault
    },

    /**
     * _numOfSubsChanged - sync number of viewWindows to `numOfSubs`
     *
     * @param  {number} newValue new `numOfSubs` value
     * @param  {number} oldValue old `numOfSubs` value
     */
    _numOfSubsChanged: function (newValue, oldValue) {
      this._initialized = false
      if (this._refObj) {
        var defaultWindows = this._refObj.settings.defaultViewWindows
        for (var i = 0; i < newValue; i++) {
          if (this.coordinates[i] !== false &&
            !give.ChromRegion.isValidChromRegion(this.coordinates[i],
              this._refObj
            ) && Array.isArray(this._refObj.settings.defaultViewWindows)
          ) {
            this.splice('coordinates', i, 1,
              defaultWindows[i % defaultWindows.length])
          }
          if (give.ChromRegion.isValidChromRegion(this.coordinates[i],
            this._refObj)
          ) {
            this.splice('_viewWindows', i, 1,
              new give.ChromRegion(this.coordinates[i], this._refObj))
          } else {
            this.splice('_viewWindows', i, 1, null)
          }
        }
        this._checkVWindowsInit()
      }
    },

    _setRefObj: function (refObj) {
      this._refObj = refObj
      this._numOfSubsChanged(this.numOfSubs)
      this._initialized = false
      this._checkVWindowsInit()
    },

    _initDOMArray: function () {
      // this is the array for visible tracks by window
      // notice that this is an array of array
      // tracks are grouped by its corresponding viewWindow Index
      this._trackDomsByWindow = []
      if (this._viewWindows.length > 0) {
        this._domsReady = false
      }
      for (var i = 0; i < this._viewWindows.length; i++) {
        var newTrackDomEntry = {
          pinAbove: [],
          scrolling: [],
          pinBelow: [],
          map: {},
          divId: give.ChartArea.DOM_DIV_ID + i
        }
        if (i < this._viewWindows.length - give.ChartArea.INTERACTION_SUBS + 1) {
          newTrackDomEntry.pinInBetween = []
        }
        if (i > 0) {
          newTrackDomEntry.hiddenTrackComponents = []
        }
        this.push('_trackDomsByWindow', newTrackDomEntry)
      }
      this.$.trackSvgHolders.render()
    },

    _initDOMCoorTracks: function () {
      if (this._refObj) {
        this._viewWindows.forEach(function (vwindow, windowIndex) {
          // coordinate track
          var coorTrackDom = this._addVisibleTrack(
            give.TrackObject.createTrack(
              'coor_' + this._refObj.db + '_' + windowIndex,
              this._createTrackProp(windowIndex,
                { type: 'coordinate', priority: 0 }
              ), this._refObj
            ), windowIndex)
          if (!windowIndex) {
            this.coorTrackZeroDOM = coorTrackDom
          }
        }, this)
      }
    },

    /**
     * Reset the entire DOM display
     */
    resetDOM: function () {
      if (this._initialized) {
        this._readiness = false
        this._initDOMArray()
      } else {
        this._readiness = true
      }
    },

    _clearDOM: function () {
      var svgList = Polymer.dom(this.$.chartHolding).querySelectorAll('svg.containedSvg')
      svgList.forEach(function (svgElem, index) {
        while (Polymer.dom(svgElem).firstChild) {
          Polymer.dom(svgElem).removeChild(Polymer.dom(svgElem).firstChild)
        }
      }, this)
      while (Polymer.dom(this.$.trackDomHolder).firstChild) {
        Polymer.dom(this.$.trackDomHolder).removeChild(Polymer.dom(this.$.trackDomHolder).firstChild)
      }
    },

    _addAllTrackDomsTracksReady: function (noRefreshContent, refObj) {
      // function called when tracks are ready for this._refObj
      if (refObj.db === this.ref) {
        // Only respond to this call if ref has not been changed
        if (!this._needOverrideDefault) {
          // no default tracks supplied, use groupIdList filter and
          // visibility settings
          // sort by priorities defined in database
          if (this.groupIdList && this.groupIdList.length > 0) {
            this.groupIdList.forEach(groupID => {
              if (this._refObj.groups.hasOwnProperty(groupID)) {
                this._refObj.groups[groupID].forEach(showTrack)
              }
            })
          } else {
            this._refObj.tracks.forEach(showTrack)
          }
        } else {
          // use this.defaultTrackIdList to directly fill in the DOM array
          // without sorting by priority (use the defaultTrackIdList order)
          // then populate SVG
          this._overrideTrackDefaultVis()
        }
        let showTrack = (track, index) => {
          // notice that if track type is 'interaction',
          // it needs to be 'unshifted' to later windows
          if (track.getSetting('visibility') >
            give.TrackObject.StatusEnum.VIS_NONE
          ) {
            this._trackDomHolder.push(new track._DomObjCtor(track), {
              subPriority: index
            })
          }
        }
        if (this.groupIdList && this.groupIdList.length > 0) {
          this.groupIdList.forEach(groupID => {
            if (this._refObj.groups.hasOwnProperty(groupID)) {
              this._refObj.groups[groupID].forEach(showTrack)
            }
          })
        } else {
          this._refObj.tracks.forEach(showTrack)
        }
        // sort trackDomBy priorities
        this._trackDomHolder.sort(
          (a, b) => give.comparePriorities(a.Priorities, b.Priorities))
        this.populateDOM(noRefreshContent)
      }
    },

    addAllTrackDoms: function (noRefreshContent) {
      this._refObj.initTracks().then(
        refObj => this._addAllTrackDomsTracksReady(noRefreshContent, refObj))
    },

    _removeInvisibleTrackDoms: function () {
      this._trackDomsByWindow.forEach(function (domInWindowEntry, windowIndex) {
        // notice that because tracks may get deleted, don't use forEach with splice
        for (var key in domInWindowEntry) {
          if (domInWindowEntry.hasOwnProperty(key) &&
            Array.isArray(domInWindowEntry[key])
          ) {
            // filter out all tracks with visibility set as 0
            // delete entries in domInWindowEntry.map first
            for (var i = 0; i < domInWindowEntry[key].length; i++) {
              if (domInWindowEntry[key][i].getTrackSetting('visibility') ===
                give.TrackObject.StatusEnum.VIS_NONE) {
                delete domInWindowEntry.map[domInWindowEntry[key][i].parent.id]
                domInWindowEntry[key].splice(i, 1)
                i--
              }
            }
          }
        }
      }, this)
    },

    _setDivElemInWindow: function (domInWindowEntry, index) {
      var reverse = (index > 0 && index === this._trackDomsByWindow.length - 1)
      if (
        !this.$$('#' + this._getElemId(domInWindowEntry.divId, 'Scroll'))
      ) {
        return false
      }
      domInWindowEntry.pinAbove.divElem = this.$$('#' +
        this._getElemId(domInWindowEntry.divId, reverse ? 'PinBottom' : 'PinTop'))
      domInWindowEntry.scrolling.divElem = this.$$('#' +
        this._getElemId(domInWindowEntry.divId, 'Scroll'))
      domInWindowEntry.pinBelow.divElem = this.$$('#' +
        this._getElemId(domInWindowEntry.divId, reverse ? 'PinTop' : 'PinBottom'))
      if (domInWindowEntry.pinInBetween) {
        domInWindowEntry.pinInBetween.divElem = this.$$('#' +
          this._getElemId(domInWindowEntry.divId, 'PinBetween'))
      }
      return true
    },

    _callForeachWithElemFuncOnDomInWindowEntry: function (func, startFunc, endFunc, domInWindowEntry, index) {
      var reverse = (index > 0 && index === this._trackDomsByWindow.length - 1)
      for (var key in domInWindowEntry) {
        if (domInWindowEntry.hasOwnProperty(key) &&
          Array.isArray(domInWindowEntry[key]) &&
          domInWindowEntry[key].divElem &&
          domInWindowEntry[key].divElem.querySelector('svg')
        ) {
          if (startFunc && typeof startFunc === 'function') {
            startFunc(domInWindowEntry[key].divElem)
          }
          var enumArray = reverse ? domInWindowEntry[key].slice().reverse()
            : domInWindowEntry[key]
          enumArray.forEach(func.bind(this,
            domInWindowEntry[key].divElem), this)
          if (endFunc && typeof endFunc === 'function') {
            endFunc(domInWindowEntry[key].divElem)
          }
        }
      }
    },

    _callForeachFuncOnDomInWindowEntry: function (func, domInWindowEntry, index) {
      var reverse = (index > 0 && index === this._trackDomsByWindow.length - 1)
      for (var key in domInWindowEntry) {
        if (domInWindowEntry.hasOwnProperty(key) &&
          Array.isArray(domInWindowEntry[key])
        ) {
          var enumArray = reverse ? domInWindowEntry[key].slice().reverse()
            : domInWindowEntry[key]
          enumArray.forEach(func, this)
        }
      }
    },

    _callEveryOnDomInWindowEntry: function (func, domInWindowEntry, index) {
      // same thing as _callForeachFuncOnDomInWindowEntry, just replace forEach by every
      var reverse = (index > 0 && index === this._trackDomsByWindow.length - 1)
      for (var key in domInWindowEntry) {
        if (domInWindowEntry.hasOwnProperty(key) &&
          Array.isArray(domInWindowEntry[key])
        ) {
          var enumArray = reverse ? domInWindowEntry[key].slice().reverse()
            : domInWindowEntry[key]
          if (!enumArray.every(func, this)) {
            return false
          }
        }
      }
      return true
    },

    _populateDomInWindow: function (domInWindowEntry, index) {
      var _populateDomInComponent = function (component, trackDom, trackDomIndex) {
        Polymer.dom(this.$.trackDomHolder).appendChild(trackDom)
        Polymer.dom(component.querySelector('svg.containedSvg')).appendChild(trackDom.getTrackSvg())
      }
      this._callForeachWithElemFuncOnDomInWindowEntry(
        _populateDomInComponent.bind(this), null, null,
        domInWindowEntry, index)
    },

    /**
     * _updateDomHeightInWindow - Update the heights of DOMs in any viewWindow
     *
     * @param  {boolean} changeWindow - index of domInWindowEntry in the array
     * @param  {[
     *   pinAbove: Array.<GIVe.TrackDomBehavior>,
     *   scrolling: Array.<GIVe.TrackDomBehavior>,
     *   pinBelow: Array.<GIVe.TrackDomBehavior>,
     *   map: Object,
     *   [pinInBetween: Array.<GIVe.TrackDomBehavior>]
     * ]} domInWindowEntry - viewWindow Array
     * @param  {number} index - index of domInWindowEntry in the array
     */
    _updateDomHeightInWindow: function (changeWindow, domInWindowEntry, index) {
      var _prepareSvgHeight = function (svgWidth, divElem) {
        divElem._currY = 0
        divElem._svgWidth = svgWidth || divElem.clientWidth
      }
      var _setDomIndHeight = function (divElem, trackDom, index) {
        trackDom.updateLocationSize(0, divElem._currY, divElem._svgWidth, null, null, changeWindow ? null : false)
        divElem._currY += trackDom.getHeight() + this._trackGap * this._textSize
      }.bind(this)
      var _setSvgWidthHeight = function (divElem) {
        if (divElem._currY > 0) {
          divElem._currY -= this._trackGap * this._textSize
        }
        Polymer.dom(divElem).querySelector('svg.containedSvg').setAttribute('width', divElem._svgWidth)
        Polymer.dom(divElem).querySelector('svg.containedSvg').setAttribute('height', divElem._currY)
        Polymer.dom(divElem).querySelector('svg.containedSvg').setAttribute('viewBox',
          '0 0 ' + divElem._svgWidth + ' ' + divElem._currY)
        delete divElem._currY
        delete divElem._svgWidth
      }.bind(this)
      this._callForeachWithElemFuncOnDomInWindowEntry(_setDomIndHeight,
        _prepareSvgHeight.bind(this, this._svgWidth),
        _setSvgWidthHeight, domInWindowEntry, index)
      this._svgWidth = this._svgWidth ||
        domInWindowEntry.scrolling.divElem.clientWidth
      if (this._svgWidth > domInWindowEntry.scrolling.divElem.clientWidth) {
        this._svgWidth = domInWindowEntry.scrolling.divElem.clientWidth
      }
      if (this._svgWidth !== domInWindowEntry.pinAbove.divElem.clientWidth) {
        // scrolling happened, needs to shrink pinned track width
        return false
      }
      return true
    },

    populateDOM: function (noRefreshContent) {
      // first clear old DOMs
      this._clearDOM()
      // then populate all new DOMS by window
      this._trackDomsByWindow.forEach(this._populateDomInWindow, this)
      this.updateHeightLocation()
      Polymer.dom.flush()
      if (!noRefreshContent) {
        // then update everything
        this.refreshAll()
      }
    },

    updateDOM: function (noRefreshContent) {
      // update existing DOMs, first remove all tracks that should be hidden
      // if noRefreshContent = true, do not refresh content (should be refreshed later)
      if (this._trackDomsByWindow && this._trackDomsByWindow.length > 0) {
        this._removeInvisibleTrackDoms()
      }

      // then add new Tracks (if not there already)
      this.addAllTrackDoms(noRefreshContent)
    },

    _updateWindowHandler: function (e) {
      // update the windows by events bubbled up from bottom tracks
      try {
        if (e.detail.newWindow instanceof give.ChromRegion ||
          typeof e.detail.newWindow === 'string'
        ) {
          var windowIndex =
            (!isNaN(parseInt(e.detail.windowIndex)) &&
              parseInt(e.detail.windowIndex) >= 0)
              ? parseInt(e.detail.windowIndex)
              : 0
          this.changeViewWindow(e.detail.newWindow, windowIndex,
            !!(e.detail.tracks))
          this.fire('update-coordinate', {
            windowIndex: windowIndex,
            newWindow: e.detail.newWindow
          })
        }
      } catch (err) {
        console.log(err.message)
        console.log(err.stack)
      }
    },

    updateWindow: function (e) {
      this._updateWindowHandler(e)
    },

    _initTrackDomContainers: function () {
      if (this._trackDomsByWindow.every(this._setDivElemInWindow, this)) {
        this._initDOMCoorTracks()
        this._domsReady = true
        if (this._initialized) {
          this.addAllTrackDoms()
        }
      } else {
        this.debounce(give.ChartArea.DOM_CHANGE_JOBNAME,
          this._initTrackDomContainers.bind(this),
          give.ChartArea.DOM_CHANGE_DEBOUNCE)
      }
    },

    _domChangeHandler: function () {
      if (!this._domsReady) {
        this.debounce(give.ChartArea.DOM_CHANGE_JOBNAME,
          this._initTrackDomContainers.bind(this),
          give.ChartArea.DOM_CHANGE_DEBOUNCE)
      }
    },

    _vWindowHasPinBetween: function () {
      return !!this._pinInBetween.length
    },

    _onIronResize: function (e, detail) {
      if (this._domsReady && this._trackDomsByWindow.every(
        this._callEveryOnDomInWindowEntry.bind(this, function (trackDom) {
          return trackDom.isReady
        }), this)
      ) {
        give._verbConsole.info('_onIronResize()')
        if (!this.resizeAsyncProcess) {
          delete this._svgWidth
          this.resizeAsyncProcess = this.async(
            this.updateHeightLocation.bind(this, false),
            this.resizeDebounceInt
          )
        }
      }
    }

  // TODO: add/remove/rearrange tracks

  })

  ChartWindow.svgNS = 'http://www.w3.org/2000/svg'

  ChartWindow.DOM_DIV_ID = 'domDiv_'
  ChartWindow.INTERACTION_SUBS = 2

  ChartWindow.DOM_CHANGE_JOBNAME = 'DOMChange'
  ChartWindow.DOM_CHANGE_DEBOUNCE = 200

  give.ChartWindow = ChartWindow
  window.customElements.define('chart-window', give.ChartWindow)

  return give
})(GIVe || {})

  </script>
</dom-module>
