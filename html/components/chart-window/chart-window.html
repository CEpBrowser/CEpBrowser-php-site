<!--
@license
Copyright 2017 GIVe Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../basic-func/basic-func.html">
<link rel="import" href="../track-object/tracks-header.html">
<link rel="import" href="../ref-embed-mixin/ref-embed-mixin.html">
<link rel="import" href="../tutorial-highlight/tutorial-highlight.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../give-styles.html">
<link rel="import" href="../chart-area/give-track-styles.html">
<link rel="import" href="../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link href="https://fonts.googleapis.com/css?family=Roboto:500,400italic,700italic,700,400" rel="stylesheet" type="text/css">
<dom-module id="chart-window">
  <template>
    <style include="give-shared-styles">
      :host {
        position: relative;
        overflow-x: hidden;
        overflow-y: auto;
        font-family: 'Roboto', Arial, Helvetica, sans-serif;
        display: block;
        margin: 0;
        padding: 0;
        width: 100%;
        @apply --layout-vertical;
        @apply --layout-flex;
      }
      div {
        margin: 0;
        padding: 0;
        border: none;
      }
      div.pinnedParts {
        @apply --layout-start;
        overflow: hidden;
      }
      div.scrollingParts {
        @apply --layout-flex;
        overflow-x: hidden;
        overflow-y: auto;
      }
      div#chartHolder {
        @apply --layout-vertical;
        @apply --layout-flex;
      }
      div#chartHolder > div {
        font-size: 0;
      }
      div#chartHolder > div > * {
        font-size: 12px;
      }
    </style>
    <style include="give-track-styles"></style>
    <div id="chartHolder">
      <div class="pinnedParts">
        <svg class="svgHolder" version="1.1" baseProfile="full"
          xmlns="http://www.w3.org/2000/svg" id="_PinTop">
        </svg>
      </div>
      <div class="scrollingParts" id="scrollingContainer">
        <svg class="svgHolder" version="1.1" baseProfile="full"
          xmlns="http://www.w3.org/2000/svg" id="_Scroll">
        </svg>
      </div>
      <div class="pinnedParts">
        <svg class="svgHolder" version="1.1" baseProfile="full"
          xmlns="http://www.w3.org/2000/svg" id="_PinBottom">
        </svg>
      </div>
    </div>
    <template is="dom-if" if="[[showTutorial]]">
      <tutorial-highlight id="coorTrackTutorial"
        tutorial-key="coor-track-tutorial"
        dom-target-id="[[_coorDomSvgId]]">
        <div>
          You may use mouse wheel within the coordinate track to zoom in/out,
          drag any track to move.
        </div>
      </tutorial-highlight>
    </template>
  </template>
  <script>
var GIVe = (function (give) {
  'use strict'

  class ResetWidthError extends Error {
    constructor (newWidth) {
      super(...arguments)
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ResetWidthError)
      }
      this.newWidth = newWidth
    }
    toString () {
      return super.toString() + '\n' + this.stack + '\nNew width:' +
        this.newWidth
    }
  }

  /**
   * ### Overview
   *
   * `<chart-window>` provides a Web Component element to interactively display
   * genomic data.
   *
   * ```html
   * <chart-window group-id-list='["genes", "singleCell"]' ref="mm10">
   * </chart-window>
   * ```
   *
   * Although `<chart-window>` does not contain the navigational control
   * elements as in `<chart-controller>`, users may still navigate by dragging
   * and mouse-wheeling on the coordinates to move around.
   *
   * Please refer to
   * [`GIVe.RefEmbedMixin`](../ref-embed-mixin/index.html) for details
   * on references used.
   *
   * ### Managing Track Priorities
   *
   * `<chart-window>` will manage track order once a view has been generated.
   * Its behavior regarding to track order will be discussed within this
   * section.
   *
   * #### Before generating a view
   *
   * `<chart-window>` shall receive an ordered list of all visible tracks from
   * its embedded `refObject`, the visibility of tracks will be supplied by its
   * `defaultTrackIdList` property, or (if said property is not set) by the
   * default `visibility` property of individual tracks.
   *
   * When the visibility of tracks have been determined, `refObject` will
   * provide a sorted list (by relative `priorities` property of the tracks) of
   * visible tracks to start with.
   *
   * #### Populating the view with tracks
   *
   * Once `<chart-window>` receives the ordered list of visible tracks, it will:
   * *   Assign every track's `trackDom`'s `<svg>` element into its
   *     corresponding slot (`top`, `scroll`, `bottom`, and `inbetween`) by
   *     inserting it into the corresponding DOM node. Notice that if this
   *     window is the last window in the view, the slots and track order will
   *     be reversed to preserve a certain degree of symmetry.
   * *   Keep record of the relative order for every `<svg>` element within its
   *     own slot.
   *     Every track object will have an __`effective priority`__ value consists
   *     of its slot allocation (`top`, `scroll`, `bottom`, and `inbetween`)
   *     and its position within the slot.
   * *   Assign the `y` property for every `<svg>` when drawing the DOM element
   *     so that it appears in the correct order regardless of its order in the
   *     DOM tree.
   *
   * #### Modifying the track list and its effect on track order
   *
   * ##### Adding new tracks
   *
   * This action may only come from the parent element.
   *
   * When a new track is being added to the visible list, it will be allocated
   * to its corresponding slot but __added to the very end of the list__. The
   * `effective priority` value of the new track will be set if not done yet.
   *
   * ##### Removing a track
   *
   * This action may come from the parent element or from the `<chart-window>`
   * itself (via a "delete" button, to be implemented).
   *
   * When an existing track is being removed, it will be delisted from the slot,
   * the `trackDom` object will be put into a recycled list (previous recycled
   * list will be cleared) and all the `visibility` values and `effective
   * priority` values will be updated accordingly.
   *
   * If this action comes from the `<chart-window>` itself, notify its parent
   * about this change.
   *
   * ##### Restoring a track previously removed (proposed, to be implemented)
   *
   * This action may only come from the parent element.
   *
   * When a restoring command was received, all `trackDom`s in the recycled list
   * will be restored to their corresponding location, their `track`'s
   * `visibility` properties and `effective priority` values will be adjusted.
   * After that, the recycled list will be cleared.
   *
   * ##### Changing the location of a track
   *
   * This action may come from the parent element or from the `<chart-window>`
   * itself (via drag-drop, to be implemented).
   *
   * The `effective priority` will be updated to the new locations if the action
   * comes from `<chart-window>` itself (this happens when user tries to alter
   * the order of the tracks).
   *
   * Then the actual `svg` `y` values will be updated to reflect the new
   * location.
   *
   * If this action comes from the `<chart-window>` itself, notify its parent
   * about this change.
   *
   * @customElement
   * @polymer
   * @appliesMixin give.RefEmbedMixin
   */
  class ChartWindow extends
    give.RefEmbedMixin(Polymer.GestureEventListeners(Polymer.Element))
  {
    constructor () {
      super()
      this._trackDoms = []
      this._hiddenTrackDoms = []
      this._addedTrackMap = new Map()
      this._hiddenTrackDomMap = new Map()

      this._pendingVWindow = null
      this._viewWindow = null

      this._svgSizes = {
        '_PinTop': 0,
        '_Scroll': 0,
        '_PinBottom': 0,
        '_PinBetween': 0
      }
    }

    static get is () {
      return 'chart-window'
    }

    static get properties () {
      return {
        /**
         * The view windows to display in the element.
         * The members of the properties should be `GIVE.ChromRegion` Objects
         * @type {GIVe.ChromRegion}
         */
        _viewWindow: {
          type: Object
        },

        index: {
          type: Number,
          value: 0
        },

        totalWindows: {
          type: Number,
          value: 1
        },

        _coorDomSvgId: {
          type: String,
          value: ''
        },

        /**
         * The view window to display in the element, in coordinate format.
         * This is for HTML attributes
         */
        coordinate: {
          type: String,
          notify: true,
          observer: '_coorChanged'
        },

        /**
         * The track groups included in the embedded browser. Group IDs are
         * specified in the data source. The data source on our server currently
         * provides these track groups:
         * *  `'genes'`: gene annotation tracks, for all available references
         * *  `'encode'`: ENCODE data sets for human and mouse, for `mm9` and
         *    `hg19` only
         * *  `'interaction'`: genomic interaction data sets, including those
         * generated from Hi-C (chromatin-chromatin) and MARGI (RNA-chromatin)
         * data, for `mm10`, `hg38` (MARGI) and `hg19` (Hi-C)
         * *  `'singleCell'`: mouse embryo single-cell RNA-seq data set from
         * [Biase *et al.*, *Genome Research*, **24**:1787-1796](http://genome.cshlp.org/content/24/11/1787.full),
         * for `mm10` only
         * @type {Array<string>}
         */
        groupIdList: {
          // this is the array of allowed group IDs in the list
          type: Array,
          value: function () {
            return []
          }
        },

        defaultTrackIdList: {
          type: Array,
          value: function () {
            return []
          }
        },

        _initialized: {
          type: Boolean,
          value: false
        },

        trackGap: Number,
        textSize: Number,
        textMargin: Number,

        /**
         * Promise resolved to the current `viewWindow` when the entire
         * `chart-window` is ready.
         * When resolved, this value will be set to `null`
         * @type {Promise}
         */
        drawingPromise: {
          type: Object,
          value: null
        },

        /**
         * Flag to indicate whether this is the first time this `chart-area`
         * element is run
         * @type {boolean}
         */
        firstRun: {
          type: Boolean,
          notify: true
        },

        showTutorial: {
          type: Boolean,
          value: false
        }
      }
    }

    ready () {
      this._updatingCoor = true
      super.ready()
      // initialize this._viewWindows from this.coordinates
      if (this.defaultTrackIdList.length > 0) {
        this._needOverrideDefault = true
      }

      this._trackPromiseAggregator = new give.PromiseAggregator(
        null, err => this._trackErrHandler(err)
      )

      this._svgList = [...this.shadowRoot.querySelectorAll('.svgHolder')]

      this.syncInBetweenSlot()
    }

    attached () {
      this.windowWidth = this.$.chartHolder.clientWidth
      if (this.coordinate) {
        this.changeCoordinate(this.coordinate)
      }
      // if (!this._initialized) {
      //   Promise.resolve().then(() => this._initDomAfterVWinRefReady())
      // }

    }

    get reverseFlag () {
      return this.index > 0 && this.index === this.totalWindows - 1
    }

    get initialized () {
      return this._initialized
    }

    get context () {
      return {
        ref: this.ref,
        index: this.index
      }
    }

    get hasInBetween () {
      return this.index < this.totalWindows - 1
    }

    get hasScroll () {
      return this.$.scrollingContainer.clientHeight <
        this.$.scrollingContainer.scrollHeight 
    }

    syncInBetweenSlot () {
      let inBetweenIndex = this._svgList.indexOf(this._pinBetweenSlot)
      if (this.hasInBetween) {
        if (!this._pinBetweenSlot) {
          this._pinBetweenSlot = document.createElementNS(
            this.constructor.svgNS, 'svg'
          )
        }
        if (inBetweenIndex < 0) {
          this._svgList.push(this._pinBetweenSlot)
        }
      } else {
        if (inBetweenIndex >= 0) {
          this._svgList.splice(inBetweenIndex, 1)
        }
        if (this._pinBetweenSlot) {
          while (this._pinBetweenSlot.firstChild) {
            this._pinBetweenSlot.removeChild(this._pinBetweenSlot.firstChild)
          }
          this._svgSizes._PinBetween = 0
        }
      }
    }

    get pinBetweenSlot () {
      return this.hasInBetween ? this._pinBetweenSlot : null
    }

    /**
     * Merge properties together
     * @todo Will be changed into `track-dom-behavior` or `basic-funcs`
     *
     * @param  {object} original - original object
     * @param  {object} newProp - object with new properties
     * @returns {object} object with the merged properties
     */
    _mergeProperty (original, newProp) {
      for (var key in newProp) {
        if (newProp.hasOwnProperty(key)) {
          original[key] = newProp[key]
        }
      }
      return original
    }

    _createTrackProp (props) {
      props = props || {}
      props.windowIndex = this.index
      props.reverseFlag = this.reverseFlag
      props.width = this.$.chartHolder.clientWidth
      props.textMargin = this.textMargin
      return props
    }

    _getSlotId (track, honorEffPriority) {
      if (honorEffPriority && track.effPriority) {
        return this._slotIdFromPinValue(
          track.effPriority.pinValue
        )
      } else {
        return this._slotIdFromPinValue(track.getSetting('pin'))
      }
    }

    _slotIdFromPinValue (pinValue) {
      pinValue = pinValue || ''
      switch (pinValue.toLowerCase()) {
        case 'top':
          return this.reverseFlag ? '_PinBottom' : '_PinTop'
        case 'bottom':
          return this.reverseFlag ? '_PinTop' : '_PinBottom'
        case 'inbetween':
          return '_PinBetween'
        default:
          return '_Scroll'
      }
    }

    _pinValueFromSlotId (slotId) {
      switch (slotId.toLowerCase()) {
        case '_pintop':
          return this.reverseFlag ? 'bottom' : 'top'
        case '_pinbottom':
          return this.reverseFlag ? 'top' : 'bottom'
        case '_pinbetween':
          return 'inbetween'
        default:
          return 'scroll'
      }
    }

    _findEffPriorIndex (effPriority) {
      return give.locationOf(effPriority, this._trackDoms, null, null,
        (effPriority, dom2) => give.EffPrior.compare(
          effPriority, dom2.parent.effPriority
        ), true
      )
    }

    _findSlotSvgElement (slotId) {
      if (slotId !== '_PinBetween') {
        return this.shadowRoot.querySelector('#' + slotId)
      } else {
        return this.pinBetweenSlot
      }
    }

    _addTrackDomSvg (trackDom, honorEffPriority) {
      if (trackDom && !this._addedTrackMap.has(trackDom.parent.id)) {
        let slotId = this._getSlotId(trackDom.parent, honorEffPriority)
        if (slotId) {
          if (!trackDom.parent.effPriority) {
            trackDom.parent.effPriority =
              new give.EffPrior(this._pinValueFromSlotId(slotId),
                this._svgSizes[slotId])
          }
          // Add DOM element
          this._findSlotSvgElement(slotId).appendChild(trackDom.trackSvg)
          // Find the correct location of the new DOM
          let domPos = this._findEffPriorIndex(trackDom.parent.effPriority)
          if (this._trackDoms[domPos] &&
            !give.EffPrior.compare(this._trackDoms[domPos].parent.effPriority,
              trackDom.parent.effPriority)
          ) {
            // Update all effPriority values for DOMs after the new DOM
            for (let i = domPos;
              i < this._trackDoms.length &&
              this._trackDoms[i].parent.effPriority.pinValue ===
              trackDom.parent.effPriority.pinValue;
              i++
            ) {
              this._trackDoms[i].parent.effPriority.pos += 1
            }
          }
          // Insert the new DOM into its correct location
          this._trackDoms.splice(domPos, 0, trackDom)

          this._addedTrackMap.set(trackDom.parent.id, trackDom)
          this._svgSizes[slotId]++

          // attach event listeners (if any)
          if (trackDom.mainGestureReceiver && trackDom.dragHandler) {
            Polymer.Gestures.addListener(trackDom.mainGestureReceiver,
              'track', e => trackDom.dragHandler(e, e.detail)
            )
            trackDom.mainGestureReceiver.addEventListener(
              'wheel', e => trackDom.wheelHandler(e, e.detail)
            )
          }
          return slotId
        }
      }
      return null
    }

    _addVisibleTrack (track, contexts, props, honorEffPriority) {
      if (!this._addedTrackMap.has(track.id) &&
        track.checkViewReq(contexts, this.index)
      ) {
        let newTrackDom = track.createDomObj(this._createTrackProp(props))
        this._addTrackDomSvg(newTrackDom, honorEffPriority)
        return newTrackDom
      }
      return null
    }

    _addHiddenTrackDom (trackDom) {
      if (trackDom && !this._hiddenTrackDomMap.has(trackDom.id) &&
        trackDom.hasLinksInTargetView(this.context)
      ) {
        this._hiddenTrackDoms.push(trackDom)
        this._hiddenTrackDomMap.set(trackDom.id, trackDom)
        return trackDom
      }
      return null
    }

    _removeTrack (tracks) {
      if (!Array.isArray) {
        tracks = [tracks]
      }
      let visibleTracksChanged = false
      tracks.forEach(track => {
        if (this._addedTrackMap.has(track.id)) {
          let trackDom = this._addedTrackMap.get(track.id)
          // This track is visible, remove the <svg> element from its slot
          this._findSlotSvgElement(
            '#' + this._slotIdFromPinValue(track.effPriority.pinValue)
          ).removeChild(trackDom.trackSvg)
          // Then remove the DOM itself
          this._trackDoms = this._trackDoms.filter(dom => {
            return dom.id !== trackDom.id
          })
          // set flag to update effPriority values
          visibleTracksChanged = true
          this._addedTrackMap.delete(track.id)
        } else {
          give._verbConsole.warn('Track ID "' + track.id + '" does not exist!')
        }
      })

      if (visibleTracksChanged) {
        // Update all effPriority values affected
        for (let slotId in this._svgSizes) {
          if (this._svgSizes.hasOwnProperty(slotId)) {
            this._svgSizes[slotId] = 0
          }
        }
        this._trackDoms.forEach(trackDom => {
          let slotId = this._pinValueFromSlotId(
            trackDom.parent.effPriority.pinValue)
          trackDom.parent.effPriority.pos = this._svgSizes[slotId].length
          this._svgSizes[slotId]++
        })
      }
    }

    _removeHiddenTrackDom (trackDomId) {
      if (trackDomId && this._hiddenTrackDomMap.has(trackDomId)) {
        this._hiddenTrackDoms.splice(
          this._hiddenTrackDoms.indexOf(
            this._hiddenTrackDomMap.get(trackDomId)
          ), 1)
        this._hiddenTrackDomMap.delete(trackDomId)
      }
    }

    /**
     * _trackEffPriorUpdated - this is used when the `effPriority` values
     *    __has been updated for all `track`s__ in the parent element, and the
     *    DOM array order needs to be restored.
     *
     * @param  {TrackObjectBase} track - the track whose `effPriority` has
     *    changed
     */
    _trackEffPriorUpdated (track, oldIndex, newIndex) {
      if (track && this._addedTrackMap.has(track.id)) {
        throw new give.GiveError('Track does not exist for track "' +
          track && track.id + '"!')
      }
      if (this._addedTrackMap.get(track.id).visible) {
        let trackDom = this._addedTrackMap.get(track.id).trackDom
        let oldIndex = this._trackDoms.indexOf(trackDom)
        if (oldIndex >= 0) {
          this._moveTrackDom(oldIndex,
            this._findEffPriorIndex(trackDom.parent.effPriority))
        } else {
          throw new give.GiveError('TrackDOM does not exist for track "' +
            track.id + '"!')
        }
      }
    }

    _moveTrackDom (oldIndex, newIndex) {
      let trackDom = this._trackDoms[oldIndex]
      this._trackDoms.splice(oldIndex, 1)
      this._trackDoms.splice(
        this._findEffPriorIndex(trackDom.parent.effPriority), 0, trackDom)
    }

    _clearDOM () {
      // clear out all the svgs
      this._svgList.forEach(svgElem => {
        while (svgElem.firstChild) {
          svgElem.removeChild(svgElem.firstChild)
        }
      }, this)
      // reset slot sizes
      for (let slotId in this._svgSizes) {
        if (this._svgSizes.hasOwnProperty(slotId)) {
          this._svgSizes[slotId] = 0
        }
      }
      // clear `this._trackDoms`
      this._trackDoms.length = 0
    }

    /**
     * _changeTrackEffPrior - change the `effPriority` value of the `track`
     *    given the `trackDom`
     *
     * @param  {TrackDom} trackDom       The `trackDom` for which `effPriority`
     *    needs to be changed.
     * @param  {give.EffPrior} newEffPriority The new `effPriority` value.
     *    Notice that the `pos` value is the new position of the `trackDom`
     *    as if its just being inserted. Therefore, it __should not consider
     *    the position of `trackDom` itself__ if the new location is after
     *    the original one.
     */
    _changeTrackEffPrior (trackDom, newEffPriority) {
      if (trackDom && newEffPriority) {
        let oldEffPriority = trackDom.parent.effPriority
        if (give.EffPrior.compare(oldEffPriority, newEffPriority)) {
          // determine if the pin value has changed
          let oldIndex = this._trackDoms.indexOf(trackDom)
          let newIndex = this._findEffPriorIndex(newEffPriority)
          if (oldEffPriority.pinValue === newEffPriority.pinValue) {
            // same pin value, just change the tracks in between
            let step = Math.sign(newIndex - oldIndex)
            for (let i = oldIndex + step;
              i * step <= newIndex * step;
              i += step
            ) {
              this._trackDoms[i].parent.effPriority.pos -= step
            }
          } else {
            // pin value is different, separate into two steps
            // -1 for all tracks with the old pin value and pos > oldPos
            for (let i = oldIndex + 1;
              i < this._trackDoms.length &&
                this._trackDoms[i].parent.effPriority.pinValue ===
                  oldEffPriority.pinValue;
              i++
            ) {
              this._trackDoms[i].parent.effPriority.pos -= 1
            }
            // +1 for all tracks with the new pin value and pos >= newPos
            for (let i = newIndex;
              i < this._trackDoms.length &&
                this._trackDoms[i].parent.effPriority.pinValue ===
                  newEffPriority.pinValue;
              i++
            ) {
              this._trackDoms[i].parent.effPriority.pos += 1
            }
          }
          trackDom.parent.effPriority = newEffPriority
          this._moveTrackDom(oldIndex, newIndex)
        } else {
          give._verbConsole.warn('Effective priority not changed.')
        }
      } else {
        throw new give.GiveError('No TrackDOM or effPriority provided!')
      }
    }

    updateSvgHeightLocation (width) {
      // update width and throw width if needed
      width = width || this.$.chartHolder.clientWidth

      this._svgList.forEach(svgElem => {
        svgElem.setAttribute('width', width)
        svgElem.setAttribute('height', svgElem._currY || 0)
        svgElem.setAttribute('viewBox',
          '0 0 ' + width + ' ' + (svgElem._currY || 0))
        delete svgElem._currY
      })
      if (this.$.scrollingContainer.clientWidth < width) {
        throw new ResetWidthError(
          this.$.scrollingContainer.clientWidth
        )
      }
      this.windowWidth = width
    }

    /**
     * @function updateTracks
     * @async
     * @param  {ChromRegionLiteral} newVWindow - Whether the view window needs
     *    to be changed to the new window, if this is falsey, then the
     *    function will call itself on pending view window or the original
     *    window.
     * @param  {number} [width] - If a new width is need to be specified
     * @return {Promise<ChromRegionLiteral>} Returns a Promise that resolves
     *    to the new window when new data was ready.
     * @throws {number} if width needs to be changed (due to scroll bar), the
     *    new width will be thrown to let the calling function (in
     *    `chart-area`) be informed of incoming width change.
     */
    updateTracks (newVWindow, width) {
      // Steps:
      // * Update all tracks' width and height (with maybe new view window)
      // * Calculate whether a scroll bar will be needed and rearrange all
      //   the svg elements by changing the Y value
      //   (by calculating and setting the height of the svgHolder element)
      //   * If a scroll bar is needed, throw the width with scroll bar
      //     factored in. Process ends to wait for the next call from the
      //     parent element (`chart-area`).
      // * Resolve the promise to the new view window
      give._verbConsole.info(
        'updateTracks(' + width + ', ' + newVWindow + ')')

      if (typeof newVWindow === 'string') {
        newVWindow = this.getVerifiedViewWindow(newVWindow)
      }
      // prepare element widths and heights
      this._pendingVWindow = newVWindow || this._pendingVWindow || false
      this._updateCoordinates()

      width = width || this.$.chartHolder.clientWidth

      // Update all tracks' width and height (with maybe new view window)
      // If no new promise is needed, do not chain stuff afterwards
      this.drawingPromise = this._trackPromiseAggregator.aggregate(
        this._trackDoms.concat(this._hiddenTrackDoms),
        trackDom => trackDom.update(
          this._pendingVWindow, width, null, false, this.index)
      )
        // * Calculate whether a scroll bar will be needed
        //   (by calculating and setting the height of the svgHolder element)
        //   * If a scroll bar is needed, throw the width with scroll bar
        //     factored in. Process ends to wait for the next call from the
        //     parent element (`chart-area`).
        .then(windows => this._trackReadyHandler(windows, width))

      return this.drawingPromise
    }

    changeWidth (width) {
      if (!this._initialized) {
        return this.resetDom().then(() => this.changeWidth(width))
      }
      width = width || this.$.chartHolder.clientWidth
      if (this._viewWindow) {
        let pendingVWindow = this._viewWindow.getExtension(
          (width - this.windowWidth) / this.windowWidth,
          null, true, this._refObj
        )
        return this.updateTracks(pendingVWindow, width)
      }
      return Promise.resolve()
    }

    _showTutorialIfNeeded () {
      if (this.firstRun && this.showTutorial &&
        this._coorDomSvg
      ) {
        this.$.coorTrackTutorial.domTargetId =
          this._coorDomSvg.id
        this.$.coorTrackTutorial.showTutorial()
      }
      this.firstRun = false
    }

    _updateTrackLocation (newWidth) {
      let enumArray = this.reverseFlag
        ? this._trackDoms.slice().reverse() : this._trackDoms
      enumArray.forEach(trackDom => {
        let svgElem = this._findSlotSvgElement(
          this._getSlotId(trackDom.parent, true)
        )
        if (svgElem.hasOwnProperty('_currY')) {
          svgElem._currY += this.trackGap * this.textSize
        } else {
          svgElem._currY = 0
        }
        trackDom.updateLocation(0, svgElem._currY)
        svgElem._currY += trackDom.height
      })
      this.updateSvgHeightLocation(newWidth)
    }

    _verifyTrackUpdateWindow (trackWindow, trackIndex, pendingVWindow) {
      if (this._trackDoms.length <= trackIndex) {
        return true
      }
      if (Array.isArray(trackWindow)) {
        trackWindow =
          trackWindow[this.index - this._trackDoms[trackIndex].windowIndex]
      }
      return !give.ChromRegion.compare(trackWindow, pendingVWindow)
    }

    _trackReadyHandler (windows, newWidth) {
      // First check whether other resizing event fired before
      // this update (otherwise the display may not be up-to-date).
      let pendingVWindow = this._pendingVWindow || this._viewWindow
      if (pendingVWindow && Array.isArray(windows) && windows.some(
        (window, index) =>
          !this._verifyTrackUpdateWindow(window, index, pendingVWindow)
      )) {
        throw new give.PromiseCanceler()
      }
      // update `this._viewWindow` and clear `this.drawingPromise`
      // `windows` is the array returned by Promise.all()
      this._trackPromiseAggregator.clear()
      delete this.drawingPromise
      this._viewWindow = pendingVWindow
      this._pendingVWindow = null
      this._updateTrackLocation(newWidth)
      // call tutorial elements if needed
      try {
        this._showTutorialIfNeeded()
      } catch (e) {
        give._verbConsole.warn(e)
        give.fireSignal('warning', { errObj: e }, null, this)
      } finally {
        this._readiness = true
      }
      return this._viewWindow
    }

    _trackErrHandler (err) {
      if (err && err.critical) {
        throw err
      }
      if (!(err instanceof give.PromiseCanceler)) {
        give._verbConsole.warn(err)
        give.fireSignal('warning', { errObj: err })
      }
      return this._pendingVWindow || this._viewWindow
    }

    getVerifiedViewWindow (coordinate) {
      try {
        // This may throw some exceptions
        // (when invalid view windows are supplied)
        return new give.ChromRegion(coordinate, this.refObj)
      } catch (err) {
        // Invalid view windows are supplied, fail gracefully
        err.data = err.data || {}
        err.data.updatedCoor =
          (this._viewWindow &&
            this._viewWindow.regionToString
          ) ? this._viewWindow.regionToString(false) : null
        throw err
      }
    }

    /**
     * _changeViewWindow - Change the range of a sub view.
     *    The range should be a `GIVE.ChromRegion` object and clipped.
     *    No exceptions should be thrown from this function.
     *
     * @param  {ChromRegionLiteral} viewWindow - The target range
     * @return {Promise<ChromRegionLiteral>} A Promise that resolves to the
     *    updated view window when the updating is done.
     * @throws {number} if width needs to be changed (due to scroll bar), the
     *    new width will be thrown to let the calling function (in
     *    `chart-area`) be informed of incoming width change.
     * @async
     */
    changeViewWindow (viewWindow) {
      if (!this._initialized) {
        return this.resetDom(viewWindow)
          .then(() => this.updateTracks(viewWindow))
      }
      return this.updateTracks(viewWindow)
    }

    _coorChanged (newValue, oldValue) {
      if (!this._updatingCoor) {
        return this.changeCoordinate(newValue)
      }
    }

    changeCoordinate (newCoordinate) {
      try {
        let newWindow = this.getVerifiedViewWindow(newCoordinate)
        let currWindow = this._pendingVWindow || this._viewWindow
        if (!currWindow || give.ChromRegion.compare(currWindow, newWindow)) {
          return this.changeViewWindow(newWindow)
        }
        throw new give.PromiseCanceler()
      } catch (err) {
        err.data = err.data || {}
        err.data.updatedCoor =
          (this._viewWindow && this._viewWindow.regionToString)
            ? this._viewWindow.regionToString(false) : null
        this._updateCoordinates()
        throw err
      }
    }

    _updateCoordinates (window) {
      window = window || this._pendingVWindow || this._viewWindow
      if (window) {
        this._updatingCoor = true
        this.coordinate = window.regionToString(false)
        this._updatingCoor = false
      }
    }

    /**
     * Get the `string` of ranges in all views
     *
     * @returns {Array<string>} The ranges, converted to `string`.
     */
    getViewWindowString () {
      return this._viewWindows.map(function (vwindow, index) {
        return vwindow.regionToString(false)
      }, this)
    }

    /**
     * _addTracksFromDefaultList - Add tracks based on
     *    `this.defaultTrackIdList` instead of the default values in
     *    the database
     */
    _addTracksFromDefaultList (contexts) {
      this.refObj.tracks.forEach(
        track => track.setSetting('visibility', false)
      )
      let exceptions = []
      this.defaultTrackIdList.forEach(id => {
        try {
          if (this.refObj.tracks.hasTrack(id)) {
            let track = this.refObj.tracks.get(id)
            track.setSetting('visibility', true)
            return this._addVisibleTrack(track, contexts)
          } else {
            give._verbConsole.info('Track ID `' + id +
              '` does not exist in ref ' + this.refObj.id)
          }
        } catch (err) {
          err.message = '[Adding Track `' + id + '`] ' + err.message
          exceptions.push(err)
          return null
        }
      })
      if (exceptions.length > 0) {
        let message = exceptions.reduce(
          (prevMessage, currErr) => (prevMessage + '\n' + currErr.message),
          'Exception occured when adding tracks:'
        )
        give._verbConsole.warn(message)
        give.fireSignal('warning', { msg: message }, null, this)
        throw new give.GiveError(message)
      }
    }

    /**
     * _addTracksFromVisibility - Add tracks based on the default
     *    `visibility` values in the database (via `track.isVisible`).
     *    Note that `this.groupIdList` will determine the track groups that
     *    will be shown here.
     */
    _addTracksFromVisibility (contexts) {
      let exceptions = []
      let showTrack = track => {
        try {
          return track.isVisible
            ? this._addVisibleTrack(track, contexts) : null
        } catch (err) {
          err.message = '[Adding Track `' + track.id + '`] ' + err.message
          exceptions.push(err)
          return null
        }
      }
      if (this.groupIdList && this.groupIdList.length > 0) {
        this.groupIdList.forEach(groupID => {
          if (this.refObj.groups.hasOwnProperty(groupID)) {
            this.refObj.groups[groupID].forEach(showTrack)
          }
        })
      } else {
        this.refObj.tracks.forEach(showTrack)
      }
      if (exceptions.length > 0) {
        let message = exceptions.reduce(
          (prevMessage, currErr) => (prevMessage + '\n' + currErr.message),
          'Exception occured when adding tracks:'
        )
        give._verbConsole.warn(message)
        give.fireSignal('warning', { msg: message }, null, this)
        throw new give.GiveError(message)
      }
    }

    _setRefObj (refObj) {
      let result = super._setRefObj(refObj)
      if (result) {
        this._initialized = false
      }
      // return this.refReadyPromise.then(refObj => {
      //   if (refObj.db !== this.ref) {
      //     // Only respond to this call if ref has not been changed
      //     throw new give.PromiseCanceler()
      //   }
      //   give.fireSignal('ref-changed', {
      //     ref: refObj.db,
      //     index: this.index
      //   }, null, this)
      //   this._initDomAfterVWinRefReady()
      // })
      return result
    }

    _initDOMCoorTrack () {
      if (this.refObj) {
        let coorTrack = give.TrackObject.createCoorTrack(
          this.refObj,
          'coor_' + this.refObj.db
        )
        this._coorDomSvg = this._addVisibleTrack(coorTrack).TrackSvg
      }
    }

    /**
     * Reset the entire DOM display without updating the DOM
     * @async If reference has not have its tracks initialized.
     */
    resetDom (contexts) {
      contexts = contexts || []
      let refReadyPromise = Promise.resolve()
      if (!this._initialized) {
        if (this.refObj) {
          refReadyPromise = this.refObj.initTracks().then(() => {
            this._initialized = true
          })
        } else {
          this._updateCoordinates()
          throw new give.GiveError('Reference not initialized.')
        }
      }
      return refReadyPromise.then(() => {
        this._clearDOM()
        this._readiness = false
        this._initDOMCoorTrack()
        return this._addAllTrackDoms(contexts)
      })
    }

    /**
     * link hidden DOMs to the window
     * @param  {Array<TrackDom>} hiddenDoms - The hidden DOM to be linked
     *    within this window
     * @param  {Array<object>} contexts - The contexts views the DOMs in
     *    this window will be linked to. contexts object should have the
     *    following properties:
     *    {
     *      ref: <string> reference of the view
     *      index: <number> index of the view
     *    }
     *    This array should at least include the neighboring windows with
     *    the same index as in `chart-area`
     * @returns {Array<TrackDom>} An array of hidden Track DOMs that needs to be
     *    linked to lower windows.
     */
    _linkHiddenDoms (hiddenDoms, contexts) {
      // add all hiddenDoms (if not already added)
      // and if they need to be further linked, put into returned list
      if (hiddenDoms && hiddenDoms.length) {
        hiddenDoms.forEach(
          hiddenDom => this._addHiddenTrackDom(hiddenDom)
        )
        return hiddenDoms.filter(hiddenDom =>
          hiddenDom.hasLinksInTargetView(contexts[this.index + 1])
        )
      } else {
        return []
      }
    }

    _addAllTrackDoms (contexts) {
      if (this._needOverrideDefault) {
        // use this.defaultTrackIdList to directly fill in the DOM array
        // without sorting by priority (use the defaultTrackIdList order)
        try {
          this._addTracksFromDefaultList(contexts)
        } finally {
          delete this._needOverrideDefault
        }
      } else {
        // no default tracks supplied, use groupIdList filter and
        // visibility settings
        // sort by priorities defined in database (this should be done
        //    in `this.refObj` already)
        this._addTracksFromVisibility(contexts)
      }
    }

    _removeInvisibleTrackDoms (contexts) {
      // Find tracks from `this._trackDoms` that become invisible now
      // then call `this._removeTrack` to remove them
      let removedTracks = this._trackDoms.map(trackDom => trackDom.parent)
        .filter(track => (
          !track.isVisible || !track.checkViewReq(contexts, this.index)
        ))
      this._removeTrack(removedTracks)
    }

    /**
     * @function updateDom - Update the DOM structure of the window WITHOUT
     *    REFRESHING THE CONTENTS (so that this function can be kept sync).
     *    This should be always called when `this._initialized` is `true`,
     *    otherwise `this.resetDom` (an async function) should be used.
     * @param  {Array<object>} contexts - Contexts for neighboring windows
     *    to check if multi-window tracks should be displayed.
     */
    updateDom (contexts) {
      // update existing DOMs, first remove all tracks that should be hidden
      contexts = contexts || []
      if (this._trackDoms && this._trackDoms.length > 0) {
        this._removeInvisibleTrackDoms(contexts)
      }

      // then add new Tracks (if not there already)
      return this._addAllTrackDoms(contexts)
    }

    /**
     * @function linkDOMs - link DOMs within this window with those within
     *    neighboring windows.
     * @param  {Array<trackDom>} hiddenDoms - The hidden DOM to be linked
     *    within this window
     * @param  {Array<object>} contexts - The contexts views the DOMs in
     *    this window will be linked to. contexts object should have the
     *    following properties:
     *    {
     *      ref: <string> reference of the view
     *      index: <number> index of the view
     *    }
     *    This array should at least include the neighboring windows with
     *    the same index as in `chart-area`
     * @param  {Boolean} keepOldLinks - Whether to keep the old hidden DOMs
     *    (for performance purposes)
     * @return {Array<trackDom>} Return the DOMs that will be linked within
     *    the next view
     */
    linkDOMs (hiddenDoms, contexts, keepOldLinks) {
      contexts = contexts || []
      if (!keepOldLinks) {
        // remove all existing hidden DOMs to severe old links
        this._hiddenTrackDomMap.clear()
        this._hiddenTrackDoms.length = 0
      }
      let linkedDoms = this._linkHiddenDoms(hiddenDoms, contexts) || []

      return linkedDoms.concat(this._trackDoms.filter(trackDom =>
        trackDom.hasLinksInTargetView(contexts[this.index + 1])))
    }
  }

  ChartWindow.ResetWidthError = ResetWidthError
  ChartWindow.svgNS = 'http://www.w3.org/2000/svg'

  give.ChartWindow = ChartWindow
  window.customElements.define('chart-window', give.ChartWindow)

  return give
})(GIVe || {})
  </script>
</dom-module>
