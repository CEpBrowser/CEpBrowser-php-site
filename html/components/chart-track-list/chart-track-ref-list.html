<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../bower_components/iron-icons/av-icons.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../give-card/give-card.html">
<link rel="import" href="chart-track-list.html">
<link rel="import" href="../ref-object/ref-object.html">
<link rel="import" href="../give-styles.html">
<!-- <link rel="import" href="../meta-track-filter/meta-track-filter.html"> -->
<link rel="import" href="../../bower_components/shadycss/apply-shim.html">
<link href="https://fonts.googleapis.com/css?family=Roboto:500,400italic,700italic,700,400" rel="stylesheet" type="text/css">
<dom-module id="chart-track-ref-list">
  <template>
    <style include="give-shared-styles iron-flex">
    :host {
      padding: 0.5em;
      display: block;
      @apply --layout-fit;
      @apply --layout-vertical;
    }
    chart-track-list {
      @apply --chart-track-list-items-mixin;
    }
    chart-track-list.selectedTracks {
      max-height: 30%;
    }
    </style>
    <template is="dom-if" if="[[showSelectedTracks]]" restamp="true">
      <give-card disable-folding>
        <chart-track-list group="[[selectedTracks]]" class="selectedTracks"
          group-icon="av:playlist-add-check"
          label="Selected tracks"
          setting-key="[[settingKey]]" is-selected
          allow-track-reordering="[[allowTrackReordering]]">
        </chart-track-list>
      </give-card>
    </template>
    <template is="dom-repeat" id="trackGroupBlock"
      items="[[groupArray]]" as="group">
      <!-- this is the track group DOM -->
      <give-card class="flex">
        <chart-track-list group="[[group.array]]"
          group-icon="[[group.icon]]"
          label="[[group.label]]" single-choice="[[group.singleChoice]]"
          setting-key="[[settingKey]]" class="flex"
          instant-change="[[instantChange]]">
        </chart-track-list>
      </give-card>
    </template>
  </template>
  <script>
var GIVe = (function (give) {
  'use strict'

  class ChartTrackRefList extends give.GiveCardContentMixin(
    give.RefEmbedMixin(give.EmbedPolymer.Element)) {
    static get is () {
      return 'chart-track-ref-list'
    }

    static get properties () {
      return {
        settingKey: {
          type: String,
          value: give.GENEMO_SELECTED_KEY
        },

        groupArray: {
          type: Array,
          value: function () {
            return []
          }
        },

        groupIdList: {
          // this is the array of allowed group IDs in the list
          type: Array
        },

        showSelectedTracks: {
          type: Boolean,
          value: false
        },

        allowTrackReordering: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the track controller will support filter function
         * @type {boolean}
         */
        withFilter: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the track controller will reflect change immediately
         * without calling this.syncDomToTrack().
         * This is always false if hasControls === true
         * @type {boolean}
         */
        instantChange: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the track controller will show OK/Cancel controls
         * @type {boolean}
         */
        hasControls: {
          type: Boolean,
          value: false
        },

        selectedTracks: {
          type: Array,
          value: function () {
            return []
          }
        },

        priorityManagers: {
          type: Object,
          value: function () {
            return {}
          }
        }
      }
    }

    ready () {
      super.ready()
    }

    /**
      * Called every time the element is inserted into the DOM. Useful for
      * running setup code, such as fetching resources or rendering.
      * Generally, you should try to delay work until this time.
      */
    connectedCallback () {
      super.connectedCallback()
      this._refChanged(this.ref)
    }

    _refreshRefTracks () {
      this.splice('groupArray', 0)
      if (this.groupIdList && this.groupIdList.length > 0) {
        this.groupIdList.forEach(groupID => {
          if (this.refObj.groups.hasOwnProperty(groupID)) {
            this.push('groupArray', this.refObj.groups[groupID])
          }
        })
      } else {
        for (let key in this.refObj.groups) {
          if (this.refObj.groups.hasOwnProperty(key)) {
            this.push('groupArray', this.refObj.groups[key])
          }
        }
      }
      Promise.resolve().then(() => {
        this.syncTrackToDom(!this.isSelected)
        this._readiness = true
      })
    }

    updateAllGroupDOM () {
      this._readiness = false
      this.refReadyPromise = this.refObj.initTracks()
        .then(() => this._refreshRefTracks())
    }

    static _prioritySort (itemA, itemB) {
      return itemA.priority < itemB.priority
        ? -1 : (itemA.priority > itemB.priority ? 1 : 0)
    }

    /**
     * Set the reference to new reference
     *
     * this will reset all tracks and redo the ref
     * note that the tracks should already be initialized before switching here
     *
     * @param  {string|GIVe.RefObject} newRef - New Reference, either name or GIVe.RefObject
     */
    _setRefObj (refObj) {
      // TODO: may need to add something to remove the override array
      if (super._setRefObj(refObj)) {
        this._readiness = false
        this.refReadyPromise = this.refObj.initTracks()
          .then(() => this._refreshRefTracks())
      }
    }

    syncTrackToDom (scrollToSelected) {
      // this is used when resetting selection
      give.forEach(this.$.trackGroupBlock.querySelectorAll('chart-track-list'),
        elem => elem.syncTrackToDom(scrollToSelected))
    }

    syncDomToTrack () {
      // this is used when submitting the results
      give.forEach(this.$.trackGroupBlock.querySelectorAll('chart-track-list'),
        elem => elem.syncDomToTrack())
    }

    resetAllTracks () {
      give.forEach(this.$.trackGroupBlock.querySelectorAll('chart-track-list'),
        elem => elem.resetAllTracks())

      // override default values if needed
      this._overrideTrackDefaultSettings()
    }

    _signalClose () {
      give.fireSignal('list-close', null, null, this)
    }

    /**
     * launchFilter - Show track filter element
     */
    launchFilter () {
      if (this.shadowRoot.querySelector('#trackFilter')) {
        this.shadowRoot.querySelector('#trackFilter').show()
      }
    }

    /**
     * _filterTracksHandler - Event handler to filter the track
     *
     * @param  {Object} e - event from the track filter element
     */
    _filterTracksHandler (e) {
      if (!e.detail.targetId || e.detail.targetId === this.id) {
        e.stopPropagation()
        this.applyFilter(e.detail.map, e.detail.flags)
      }
      // Otherwise the filter wants to change some other list (extremely rare),
      // when whoever listens to filter-tracks event will handle.
    }

    submitChanges () {
      this.syncDomToTrack()
      this._signalClose()
    }

    cancelChanges () {
      this.syncTrackToDom()
      this._signalClose()
    }

    applyFilter (map, flags) {
      give.forEach(this.$.trackGroupBlock.querySelectorAll('chart-track-list'),
        elem => elem.applyFilter(map, flags))
    }
  }

  give.ChartTrackRefList = ChartTrackRefList
  window.customElements.define(
    'chart-track-ref-list', give.ChartTrackRefList)

  return give
})(GIVe || {})
  </script>
</dom-module>
