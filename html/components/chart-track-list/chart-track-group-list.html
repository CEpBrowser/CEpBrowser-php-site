<!--
  List for tracks within one track group
  This DOM element must be placed in a flex container,
  otherwise the iron-list will not work
-->

<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/iron-list/iron-list.html">
<link rel="import" href="../../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../track-control/track-mini-control.html">
<link rel="import" href="../give-card/give-card-content-mixin.html">
<link rel="import" href="../ref-embed-mixin/ref-embed-mixin.html">
<link rel="import" href="../give-styles.html">
<link rel="import" href="../../bower_components/shadycss/apply-shim.html">
<link href="https://fonts.googleapis.com/css?family=Roboto:500,400italic,700italic,700,400" rel="stylesheet" type="text/css">
<dom-module id="chart-track-group-list">
  <template>
    <style include="give-shared-styles iron-flex">
      :host {
        padding: 0.6em 0;
        position: relative;
        min-height: 2.65em;
        @apply --layout-vertical;
        @apply --layout-flex;
      }
      iron-list {
        padding: 0 1em;
        overflow-x: hidden;
        --iron-list-items-container: {
           @apply --chart-track-list-items-mixin;
        };
      }
    </style>
    <template is="dom-if" if="[[_listEmpty(groupArray)]]">
      <div><em>(No tracks)</em></div>
    </template>
    <iron-list id="groupList" items="[[group.array]]" as="track"
      class="flex"
      selection-enabled
      multi-selection$="[[_computeSingleChoice(group)]]"
      on-selected-items-changed="_selectedItemsChangedHandler"
      selected-items="{{selected}}">
      <template>
        <track-mini-control track="[[track]]"
          selected="[[selected]]"
          single-choice="[[_computeSingleChoice(group)]]">
        </track-mini-control>
      </template>
    </iron-list>
  </template>
  <script>
var GIVe = (function (give) {
  'use strict'

  class ChartTrackGroupList extends give.GiveCardContentMixin(Polymer.Element) {
    static get is () {
      return 'chart-track-group-list'
    }

    static get properties () {
      return {
        settingKey: {
          type: String,
          value: give.GENEMO_SELECTED_KEY
        },

        group: {
          type: Object,
          observer: '_groupChanged'
        },

        instantChange: {
          type: Boolean,
          value: false
        },

        isSelected: {
          type: Boolean,
          value: false
        },

        allowTrackReordering: {
          type: Boolean,
          value: false
        },

        selected: {
          type: Array,
          value: function () {
            return []
          }
        },

        label: {
          type: String,
          value: ''
        },

        groupIcon: {
          type: String,
          value: null
        }
      }
    }

    ready () {
      super.ready()
      this._allowFlexShrink = !this.isSelected
      if (this.group) {
        this.groupIcon = this.groupIcon || this.group.icon
        this.label = this.label || this.group.label
      }
      this._setIcon(this.groupIcon || null)
      this._setIconAlt(this.label || 'Track group')
      this._setHeaderText(this.label || 'Track group')
    }

    /**
      * Called every time the element is inserted into the DOM. Useful for
      * running setup code, such as fetching resources or rendering.
      * Generally, you should try to delay work until this time.
      */
    connectedCallback () {
      super.connectedCallback()
      this.domReadyPromise = new Promise((resolve, reject) => {
        Polymer.RenderStatus.beforeNextRender(this, () => {
          if (this.isSelected) {
            this._syncGroupToSelection()
          }
          give._verbConsole.info('chartTrackGroupList: ready.')
          this._readiness = true
          resolve()
        })
      })
    }

    get contentHeight () {
      if (this.group) {
        return this._calcHeightBasedOnLines(this.displayedLines)
      }
      return null
    }

    get allowFlexShrink () {
      return this._allowFlexShrink &&
        this.displayedLines > this.constructor.MIN_SHRINKABLE_DISPLAY_LINES
    }

    _syncGroupToSelection () {
      this._updatingSelectedItems = true
      this.selected = this.group.slice()
      this._updatingSelectedItems = false
    }

    _syncSelectionToGroup () {
      this._updatingSelectedItems = true
      // this.groupArray = this.selected.slice()
      this.group = give.TrackGroup.from(this.selected, this.group.id,
        this.group, this.group.IDPrefix, this.group.IDPostfix)
      this._updatingSelectedItems = false
    }

    _computeSingleChoice (group) {
      return group.singleChoice && group.singleChoice !== '0'
    }

    _listEmpty (array) {
      return !array || !array.length
    }

    syncTrackSettingsToDom (scrollToSelected) {
      // this is used when resetting selection
      // DOM means this.$.groupList.selectedItems
      if (this.group) {
        this.$.groupList.clearSelection()
        let firstSelected = null
        this.group.every((track, index) => {
          if (track.getSetting(this.settingKey)) {
            if (firstSelected === null) {
              firstSelected = index
            }
            this.$.groupList.selectIndex(index)
            return this.$.groupList.multiSelection
          }
          return true
        })
        if (scrollToSelected && firstSelected !== null) {
          // scroll to first selected item
          this.$.groupList.scrollToIndex(firstSelected)
        }
      }
    }

    syncDomToTrackSettings () {
      // this is used when submitting the results
      if (this.group) {
        this.group.forEach((track, index) =>
          track.setSetting(this.settingKey, false)
        )
        if (this.$.groupList.selectedItems) {
          if (Array.isArray(this.$.groupList.selectedItems)) {
            this.$.groupList.selectedItems.forEach(track =>
              track.setSetting(this.settingKey, true))
          } else {
            this.$.groupList.selectedItem.setSetting(this.settingKey, true)
          }
        }
      }
    }

    resetAllTracks () {
      if (this.group) {
        this.group.forEach(track => track.resetSetting(this.settingKey))
        this.syncTrackToDom()
      }
    }

    applyFilter (map, flags) {
      this.group.forEach((track, index) => {
        if (flags.hasOwnProperty('matched') && map.hasOwnProperty(track.id)) {
          if (flags.matched) {
            this.$.groupList.selectIndex(index)
          } else {
            this.$.groupList.deselectIndex(index)
          }
        } else if (
          flags.hasOwnProperty('unmatched') && !map.hasOwnProperty(track.id)
        ) {
          if (flags.unmatched) {
            this.$.groupList.selectIndex(index)
          } else {
            this.$.groupList.deselectIndex(index)
          }
        }
      })
    }

    _selectedItemsChangedHandler (e) {
      if (this._readiness && !this._updatingSelectedItems) {
        if (this.instantChange) {
          this.syncDomToTrack()
        }
        if (this.isSelected) {
          // remove the item that is not selected, then refresh the list
          this._syncSelectionToGroup()
        }
        give.fireSignal('selection-change', e.detail, null, this)
      }
    }

    _groupArrayChanged (newValue, oldValue) {
      if (this.isSelected && !this._updatingSelectedItems) {
        this._syncGroupToSelection()
      }
    }

    syncSelectionFromGroup (selectionGroup) {
      this._updatingSelectedItems = true
      // select the ones in `selectionSet` but not in `this.selected`
      selectionGroup.forEach(track => {
        if (this.group.hasTrack(track)) {
          this.$.groupList.selectItem(track)
        }
      })
      // deselect the ones in `this.selected` but not in `selectionSet`
      this.selected.forEach(track => {
        if (!selectionGroup.hasTrack(track)) {
          this.$.groupList.deselectItem(track)
        }
      })
      this._updatingSelectedItems = false
    }

    get displayedLines () {
      if (!this.group || !this.group.length) {
        return 1
      }
      return Math.min(this.group.length,
        this.isSelected
          ? this.constructor.MAX_DISPLAY_LINES_SELECTED
          : this.constructor.MAX_DISPLAY_LINES)
    }

    _calcHeightBasedOnLines (lines) {
      return (lines * give.TrackMiniControl.heightProportion + 1.2) *
        parseFloat(window.getComputedStyle(this.shadowRoot.host)
          .getPropertyValue('font-size'))
    }

    // get _flexShrinkRatio () {
    //   if (this.group) {
    //     let displayedLines = this.displayedLines
    //     return displayedLines <= this.constructor.MIN_SHRINKABLE_DISPLAY_LINES
    //       ? 0 : this._calcHeightBasedOnLines(displayedLines)
    //   }
    // }

    get minContentHeight () {
      let displayedLines = this.displayedLines
      return displayedLines <= this.constructor.MIN_SHRINKABLE_DISPLAY_LINES
        ? this._calcHeightBasedOnLines(displayedLines)
        : this._calcHeightBasedOnLines(
          this.constructor.MIN_SHRINKABLE_DISPLAY_LINES
        )
    }
  }

  ChartTrackGroupList.MAX_DISPLAY_LINES_SELECTED = 8
  ChartTrackGroupList.MAX_DISPLAY_LINES = 25
  ChartTrackGroupList.MIN_SHRINKABLE_DISPLAY_LINES = 5

  give.ChartTrackGroupList = ChartTrackGroupList
  window.customElements.define(
    'chart-track-group-list', give.ChartTrackGroupList)

  return give
})(GIVe || {})
  </script>
</dom-module>
