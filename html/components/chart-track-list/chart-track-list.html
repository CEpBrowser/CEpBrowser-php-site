<!--
  List for tracks within one track group
  This DOM element must be placed in a flex container,
  otherwise the iron-list will not work
-->

<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-classes.html">
<link rel="import" href="../../bower_components/iron-list/iron-list.html">
<link rel="import" href="../../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../track-control/track-mini-control.html">
<link rel="import" href="../give-styles.html">
<link rel="import" href="../../bower_components/shadycss/apply-shim.html">
<link href="https://fonts.googleapis.com/css?family=Roboto:500,400italic,700italic,700,400" rel="stylesheet" type="text/css">
<dom-module id="chart-track-list">
  <template>
    <style include="give-shared-styles iron-flex">
      :host {
        padding: 1em;
        @apply --layout-vertical;
        position: relative;
      }
      iron-list {
        --iron-list-items-container: {
           @apply --chart-track-list-items-mixin;
        };
      }
    </style>
    <template is="dom-if" if="[[_listEmpty(group)]]">
      <div><em>(No tracks)</em></div>
    </template>
    <iron-list id="groupList" items="[[group]]" as="track"
      selection-enabled multi-selection$="[[!singleChoice]]"
      on-selected-items-changed="_selectedItemsChangedHandler"
      selected="{{selected}}">
      <template>
        <track-mini-control track="[[track]]" group="[[group]]"
          selected="[[selected]]"
          single-choice="[[_computeSingleChoice(singleChoice)]]">
        </track-mini-control>
      </template>
    </iron-list>
  </template>
  <script>
var GIVe = (function (give) {
  'use strict'

  class ChartTrackList extends give.GiveCardContentMixin(Polymer.Element) {
    static get is () {
      return 'chart-track-list'
    }

    static get properties () {
      return {
        settingKey: {
          type: String,
          value: give.GENEMO_SELECTED_KEY
        },

        group: {
          type: Array,
          value: function () {
            return []
          },
          observer: '_groupChanged'
        },

        instantChange: {
          type: Boolean,
          value: false
        },

        isSelected: {
          type: Boolean,
          value: false
        },

        allowTrackReordering: {
          type: Boolean,
          value: false
        },

        selected: {
          type: Array,
          value: function () {
            return []
          }
        },

        label: {
          type: String,
          value: ''
        },

        singleChoice: {
          type: String,
          value: null
        },

        groupIcon: {
          type: String,
          value: null
        }
      }
    }

    ready () {
      super.ready()
      this._setIcon(this.groupIcon || null)
      this._setIconAlt(this.label || 'Track group')
      this._setHeaderText(this.label || 'Track group')
      if (this.isSelected) {
        this.shadowRoot.style.height =
          this.group.length * give.TrackMiniControl.heightProportion +
          'em'
        this.$.groupList.classList.add('fit')
        this._syncGroupToSelection()
        this.selected = this.group.slice()
      } else {
        this.$.groupList.classList.add('flex')
      }
    }

    _syncGroupToSelection () {
      this._updatingSelectedItems = true
      this.selected = this.group.slice()
      this._updatingSelectedItems = false
    }

    _syncSelectionToGroup () {
      this._updatingSelectedItems = true
      this.group = this.selected.slice()
      this._updatingSelectedItems = false
    }

    _computeSingleChoice (singleChoice) {
      return singleChoice && singleChoice !== '0'
    }

    _listEmpty (array) {
      return array && array.length > 0
    }

    syncTrackToDom (scrollToSelected) {
      // this is used when resetting selection
      // DOM means this.$.groupList.selectedItems
      if (this.group) {
        this.$.groupList.clearSelection()
        let firstSelected = null
        this.group.every((track, index) => {
          if (track.getSetting(this.settingKey)) {
            if (firstSelected === null) {
              firstSelected = index
            }
            this.$.groupList.selectIndex(index)
            return this.$.groupList.multiSelection
          }
          return true
        })
        if (scrollToSelected && firstSelected !== null) {
          // scroll to first selected item
          this.$.groupList.scrollToIndex(firstSelected)
        }
      }
    }

    syncDomToTrack () {
      // this is used when submitting the results
      if (this.group) {
        this.group.forEach((track, index) =>
          track.setSetting(this.settingKey, false)
        )
        if (this.$.groupList.selectedItems) {
          if (Array.isArray(this.$.groupList.selectedItems)) {
            this.$.groupList.selectedItems.forEach(function (track) {
              track.setSetting(this.settingKey, true)
            }, this)
          } else {
            this.$.groupList.selectedItems.setSetting(this.settingKey, true)
          }
        }
      }
    }

    resetAllTracks () {
      if (this.group) {
        this.group.forEach(track => track.resetSetting(this.settingKey))
        this.syncTrackToDom()
      }
    }

    applyFilter (map, flags) {
      this.group.forEach((track, index) => {
        if (flags.hasOwnProperty('matched') && map.hasOwnProperty(track.id)) {
          if (flags.matched) {
            this.$.groupList.selectIndex(index)
          } else {
            this.$.groupList.deselectIndex(index)
          }
        } else if (
          flags.hasOwnProperty('unmatched') && !map.hasOwnProperty(track.id)
        ) {
          if (flags.unmatched) {
            this.$.groupList.selectIndex(index)
          } else {
            this.$.groupList.deselectIndex(index)
          }
        }
      })
    }

    _selectedItemsChangedHandler (e) {
      if (!this._updatingSelectedItems) {
        if (this.instantChange) {
          this.syncDomToTrack()
        }
        if (this.isSelected) {
          // remove the item that is not selected, then refresh the list
          this._syncSelectionToGroup()
        }
        give.fireSignal('selected-item-changed', e.detail, null, this)
      }
    }

    _groupChanged (newValue, oldValue) {
      if (this.isSelected && !this._updatingSelectedItems) {
        this._syncGroupToSelection()
      }
    }
  }

  give.ChartTrackList = ChartTrackList
  window.customElements.define('chart-track-list', give.ChartTrackList)

  return give
})(GIVe || {})
  </script>
</dom-module>
