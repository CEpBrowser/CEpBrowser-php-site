<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/utils/render-status.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../bower_components/iron-icons/av-icons.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../give-card/give-card.html">
<link rel="import" href="chart-track-ref-list.html">
<link rel="import" href="chart-track-group-list.html">
<link rel="import" href="../ref-object/ref-object.html">
<link rel="import" href="../give-styles.html">
<!-- <link rel="import" href="../meta-track-filter/meta-track-filter.html"> -->
<link rel="import" href="../../bower_components/shadycss/apply-shim.html">
<link href="https://fonts.googleapis.com/css?family=Roboto:500,400italic,700italic,700,400" rel="stylesheet" type="text/css">
<dom-module id="chart-track-list">
  <template>
    <style include="give-shared-styles iron-flex">
    :host {
      padding: 0.5em;
      display: block;
      @apply --layout-vertical;
    }
    chart-track-group-list {
      @apply --chart-track-list-items-mixin;
    }
    give-card {
      margin: 0 0 0.5em 0;
    }
    .cardActions {
      padding: 0;
      margin-bottom: -0.5em;
    }
    </style>
    <!-- Selected tracks DOM, by reference -->
    <template is="dom-if" if="[[showSelectedTracks]]" restamp="true">
      <template is="dom-repeat" id="selectedTracksBlock"
        items="{{_refItemArray}}" as="refItemSelected">
        <give-card disable-folding>
          <chart-track-group-list slot="body"
            group="{{refItemSelected.selectedTracks}}"
            group-icon="av:playlist-add-check"
            label="[[_calcSelectedTrackGroupLabel(refItemSelected.refObj)]]"
            setting-key="[[settingKey]]" is-selected
            allow-track-reordering="[[allowTrackReordering]]"
            on-selection-change="_selectionChangedInSelectedTracks">
          </chart-track-group-list>
        </give-card>
      </template>
    </template>
    <template is="dom-repeat" id="trackRefBlock"
      items="{{_refItemArray}}" as="refItem">
      <!-- Candidate tracks DOM, by reference -->
      <give-card class="flex">
        <chart-track-ref-list slot="body"
          ref="[[refItem.db]]" has-parent
          group-icon="[[_calcRefIcon(refItem.refObj)]]"
          label="[[_calcRefLabel(refItem.refObj)]]"
          setting-key="[[settingKey]]"
          group-id-list="[[groupIdList]]"
          selected-tracks="{{refItem.selectedTracks}}"
          instant-change="[[instantChange]]"
          priority-manager="[[_calcPriorityManager(refItem.db)]]">
        </chart-track-ref-list>
      </give-card>
    </template>
    <div class="cardActions">
      <template is="dom-if" if="[[withFilter]]" restamp="true">
        <paper-button on-tap="launchFilter">
          <iron-icon icon="filter-list"></iron-icon>
          Filter
        </paper-button>
        <paper-button on-tap="resetAllTracks">
          <iron-icon icon="refresh"></iron-icon>
          Reset to default
        </paper-button>
        <!-- <meta-track-filter id="trackFilter" ref='[[ref]]'
          on-filter-tracks="_filterTracksHandler"></meta-track-filter> -->
      </template>
      <template is="dom-if" if="[[hasControls]]" restamp="true">
        <paper-button on-tap="cancelChanges">
          <iron-icon icon="close"></iron-icon>
          Cancel
        </paper-button>
        <paper-button on-tap="submitChanges">
          <iron-icon icon="check"></iron-icon>
          OK
        </paper-button>
      </template>
    </div>
  </template>
  <script>
var GIVe = (function (give) {
  'use strict'

  class ChartTrackList extends Polymer.Element {
    constructor () {
      super(...arguments)
      this._updatingRef = false
      this._refTrackLists = []
      this.domReadyPromise = null
      this._updatingSelection = false
    }

    static get is () {
      return 'chart-track-list'
    }

    static get properties () {
      return {
        settingKey: {
          type: String,
          value: give.GENEMO_SELECTED_KEY
        },

        _refItemArray: {
          type: Array,
          value: function () {
            return []
          }
        },

        groupIdList: {
          // this is the array of allowed group IDs in the list
          type: Array
        },

        showSelectedTracks: {
          type: Boolean,
          value: false
        },

        allowTrackReordering: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the track controller will support filter function
         * @type {boolean}
         */
        withFilter: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the track controller will reflect change immediately
         * without calling this.syncDomToTrackSettings().
         * This is always false if hasControls === true
         * @type {boolean}
         */
        instantChange: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the track controller will show OK/Cancel controls
         * @type {boolean}
         */
        hasControls: {
          type: Boolean,
          value: false
        },

        defaultTrackIdList: {
          type: Array,
          value: function () {
            return []
          }
        },

        ref: {
          type: String,
          value: '',
          observer: '_refChanged'
        },

        priorityManagers: {
          type: Object,
          value: function () {
            return {}
          }
        }
      }
    }

    ready () {
      this._updatingRef = true
      super.ready()
    }

    /**
      * Called every time the element is inserted into the DOM. Useful for
      * running setup code, such as fetching resources or rendering.
      * Generally, you should try to delay work until this time.
      */
    connectedCallback () {
      super.connectedCallback()
      Polymer.RenderStatus.beforeNextRender(this, () => {
        this._updatingRef = false
        this._refChanged(this.ref)
      })
    }

    _calcRefIcon (refObj) {
      return refObj.iconLabel
    }

    _calcRefLabel (refObj) {
      return refObj.commonName + ' (reference ' + refObj.db + ') tracks'
    }

    _calcPriorityManager (db) {
      return this.priorityManagers[db]
    }

    _calcSelectedTrackGroupLabel (refObj) {
      return 'Selected tracks for ' +
        refObj.commonName + ' (reference ' + refObj.db + ')'
    }

    /**
     * _refreshRefTracks - refresh the selected status of all reference tracks
     *    and update `this._selectedTracks` object (and the DOMs associated with
     *    `this._selectedTracks`).
     *
     * @return {Promise<object>} A promise that resolves to
     *    `this._selectedTracks`.
     */
    _refreshRefTracks (scrollToSelected) {
      return new Promise((resolve, reject) => {
        Polymer.RenderStatus.afterNextRender(this, () => {
          this._refTrackLists =
            [...this.shadowRoot.querySelectorAll('chart-track-ref-list')]
          // By this time the `refObj`s should all have been initialized by
          //    `this.groupIdList` and/or `this.defaultIdList`
          resolve(Promise.all(this._refTrackLists.map(
            elem => elem.domReadyPromise
          )).then(() => {
            this._readiness = true
            this.syncPriorityManagerToDom(scrollToSelected)
            return this
          }))
        })
      })
    }

    _getUniqueRefArrayFromJson (refJsonString) {
      refJsonString = refJsonString || this.ref
      let refSet = new Set()
      let refArray = [refJsonString]
      try {
        let parsed = JSON.parse(refJsonString)
        if (Array.isArray(parsed)) {
          refArray = parsed
        }
      } catch (ignore) { }
      if (refArray.length <= 0) {
        return []
      } else {
        refArray.forEach(ref => refSet.add(ref))
      }
      return [...refSet.values()]
    }

    _syncRefJsonToArray () {
      let refArray = this._getUniqueRefArrayFromJson(this.ref)
      this._refItemArray = refArray.map((refDbName, index) => {
        let refObj = give.RefObject.findRefByDb(refDbName)
        if (!this.priorityManagers.hasOwnProperty(refObj.db)) {
          this.priorityManagers[refObj.db] = new give.PriorityManager(
            refObj, this.defaultTrackIdList, this.groupIdList)
        }
        return {
          db: refDbName,
          refObj: give.RefObject.findRefByDb(refDbName),
          selectedTracks: new give.TrackGroup()
        }
      })
      return Promise.all(
        this._refItemArray.map(
          refItem => this.priorityManagers[refItem.db].readyPromise
        )
      )
    }

    _refChanged (newValue, oldValue) {
      if (!this._updatingRef) {
        return (this.domReadyPromise = this._syncRefJsonToArray()
          .then(() => this._refreshRefTracks(true)))
      }
    }

    static _prioritySort (itemA, itemB) {
      return itemA.priority < itemB.priority
        ? -1 : (itemA.priority > itemB.priority ? 1 : 0)
    }

    syncPriorityManagerToDom (scrollToSelected) {
      // this is used when resetting selection
      if (!this._readiness) {
        throw new give.GiveError('Track list not initialized!')
      }
      this._refTrackLists.forEach(
        refTrackElem => refTrackElem.syncPriorityManagerToDom(scrollToSelected))
    }

    syncDomToTrackSettings () {
      // this is used when submitting the results
      if (!this._readiness) {
        throw new give.GiveError('Track list not initialized!')
      }
      this._refTrackLists.forEach(
        refTrackElem => refTrackElem.syncDomToTrackSettings())
    }

    resetAllTracks () {
      if (!this._readiness) {
        throw new give.GiveError('Track list not initialized!')
      }
      this._refTrackLists.forEach(
        refTrackElem => refTrackElem.resetAllTracks())
    }

    _signalClose () {
      give.fireSignal('list-close', null, null, this)
    }

    /**
     * launchFilter - Show track filter element
     */
    launchFilter () {
      if (this.shadowRoot.querySelector('#trackFilter')) {
        this.shadowRoot.querySelector('#trackFilter').show()
      }
    }

    /**
     * _filterTracksHandler - Event handler to filter the track
     *
     * @param  {Object} e - event from the track filter element
     */
    _filterTracksHandler (e) {
      if (!e.detail.targetId || e.detail.targetId === this.id) {
        e.stopPropagation()
        this.applyFilter(e.detail.map, e.detail.flags)
      }
      // Otherwise the filter wants to change some other list (extremely rare),
      // when whoever listens to filter-tracks event will handle.
    }

    _selectionChangedInSelectedTracks (e) {
      if (!this._updatingSelection) {
        this._updatingSelection = true
        this._refTrackLists.forEach(
          elem => elem._selectionChangedInSelectedTracks())
        this._updatingSelection = false
      }
    }

    submitChanges () {
      this.syncDomToTrackSettings()
      this._signalClose()
    }

    cancelChanges () {
      this.syncPriorityManagerToDom()
      this._signalClose()
    }

    applyFilter (map, flags) {
      if (!this._readiness) {
        throw new give.GiveError('Track list not initialized!')
      }
      this._refTrackLists.forEach(
        refTrackElem => refTrackElem.applyFilter(map, flags))
    }
  }

  give.ChartTrackList = ChartTrackList
  window.customElements.define('chart-track-list', give.ChartTrackList)

  return give
})(GIVe || {})
  </script>
</dom-module>
