<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../genemo-styles.html">
<link rel="import" href="./genemo-track-styles.html">
<link rel="import" href="./tracks-header.html">
<link href="http://fonts.googleapis.com/css?family=Roboto:500,400italic,700italic,700,400" rel="stylesheet" type="text/css">
<dom-module id="tracks-backbone">
  <template>
    <style include="genemo-shared-styles">
        #trackDOMHolder {
            display: none;
        }
		:host {
			margin: 1.2em 0;
		}
    </style>
    <style include="genemo-track-styles"></style>
    <svg id="mainSvg" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
	</svg>
    <div id="trackDOMHolder"></div>
  </template>
  <script>
  	TracksBackbone = Polymer({
		is: "tracks-backbone",
		
		// to
		
		behaviors: [
			Polymer.IronResizableBehavior
		],
		
		properties: {
			species: Object, // this is the species defined in libtracks.js
			// notice that species should have chromSizes and location of centromeres included
			// tracks is also within species
			// may need to provide additional API to get track data
			
			viewWindows: {
				// this will be an array of strings (viewWindowString),
				// may be changed to viewWindows directly for performance in the future
				type: Array,
				value: function() {
					return [];
				}
			},
			
			initialized: {
				type: Boolean,
				value: false,
				readOnly: true,
			},
			
			trackGap: {
				type: Number,
				value: 0.3,		// unit is em
			},
			
			textSize: {
				type: Number,
				value: 12,		// unit is px
			},
			
		},
		
		listeners: {
			'track-ready': 'trackReadyHandler',
		},
		
		created: function() {
			this.svgNS = "http://www.w3.org/2000/svg";
		},
		
		factoryImpl: function(species, numOfSubs, viewWindow, threshold) {
			this.threshold = threshold || 1.0;
			this.changeSpecies(species, numOfSubs, viewWindow);
		},
		
		createBedTrackProp: function(viewWindowIndex, properties) {
			return {x: 0, y: 0, width: this.$.mainSvg.offsetWidth,
					textMargin: 100, requestUrl: Track.fetchDataTarget,
					};
		},
		
		createCoorTrackProp: function(viewWindowIndex, properties) {
			return {x: 0, y: 0, width: this.$.mainSvg.offsetWidth,
					textMargin: 100, labelLocation: ((viewWindowIndex === 0)? 'up': 'down'),
					};
		},
		
		createInteractionTrackProp: function(viewWindowIndex, properties) {
			return {x: 0, y: 0, width: this.$.mainSvg.offsetWidth,
					textMargin: 100, requestUrl: Track.fetchDataTarget,
					numOfSubs: this.viewWindows.length,
					};
		},
		
		createTrackProp: function(track, viewWindowIndex, props) {
			var trackDOMMap = {
				bed: this.createBedTrackProp.bind(this),
				genebed: this.createBedTrackProp.bind(this),
				genepred: this.createBedTrackProp.bind(this),
				interaction: this.createInteractionTrackProp.bind(this),
				coordinate: this.createCoorTrackProp.bind(this),
			};
			return trackDOMMap[track.getTypeTrunk()](viewWindowIndex, props);
		},
		
		createTrackDOM: function(track, viewWindowIndex, props) {
			var trackDOMMap = {
				bed: BedTrack,
				genebed: BedTrack,
				genepred: BedTrack,
				interaction: InteractionTrack,
				coordinate: CoorTrack,
			};
			// temporary measures: do not create Track DOM 
			//					   if viewWindowIndex > 0 and track.getTypeTrunk() === 'interaction'
			if(viewWindowIndex > 0 && track.getTypeTrunk() === 'interaction') {
				return null;
			}
			return new trackDOMMap[track.getTypeTrunk()](track, 
								this.createTrackProp(track, viewWindowIndex, props));
		},
		
		addOrdinaryTrackDOM: function(trackDOM, viewWindowIndex) {
			this.trackDOMsByWindow[viewWindowIndex].splice(
					locationOf(trackDOM, this.trackDOMsByWindow[viewWindowIndex], 
						null, null, function(trackDOM1, trackDOM2) {
							return trackDOM1.track.priority < trackDOM2.track.priority? -1: 
								trackDOM1.track.priority > trackDOM2.track.priority? 1: 0;
						}) + 1,
					0, trackDOM);
		},
		
		addInteractionTrackDOM: function(trackDOM, viewWindowIndex) {
			// actually this will enum all viewWindowIndices
			this.viewWindows.forEach(function(vwindow, index) {
				this.addOrdinaryTrackDOM(trackDOM, index);
			}, this);
		},
		
		addVisibleTrack: function(track, viewWindowIndex) {
			var trackDOMAddMap = {
				bed: this.addOrdinaryTrackDOM.bind(this),
				genebed: this.addOrdinaryTrackDOM.bind(this),
				genepred: this.addOrdinaryTrackDOM.bind(this),
				coordinate: this.addOrdinaryTrackDOM.bind(this),
				interaction: this.addInteractionTrackDOM.bind(this),
			};
			var newTrackDOM = this.createTrackDOM(track, viewWindowIndex);
			if(newTrackDOM) {
				trackDOMAddMap[track.getTypeTrunk()](newTrackDOM, viewWindowIndex);
			}
		},
		
		mergeTrackDOMsByWindow: function() {
			this.trackDOMs.splice(0, this.trackDOMs.length);
			this.trackDOMsByWindow.forEach(function(indTrackDOMs, windowIndex) {
				if(windowIndex !== 0) {
					indTrackDOMs.reverse();
				}
				indTrackDOMs.forEach(function(track, trackIndex) {
					if(!track._domMergeFlag) {
						this.trackDOMs.push(track);
						track._domMergeFlag = true;
					}
				}, this);
			}, this);
			this.trackDOMs.forEach(function(track) {
				delete track._domMergeFlag;
			}, this);			
		},
		
		updateHeightLocation: function() {
			// calculate the heights for all tracks
			// note that by the time this is called, all tracks should be ready
			// (this is handled in track-ready event handler)
			// this will also rearrange the y value for all tracks as well
			var currY = 0;
			this.trackDOMs.forEach(function(trackDOM, index) {
				trackDOM.updateLocationSize(0, currY);
				currY += trackDOM.getHeight() + this.trackGap * this.textSize;
			}, this);
			currY -= this.trackGap * this.textSize;
			this.$.mainSvg.setAttribute("height", currY);
			this.$.mainSvg.setAttribute("viewBox", "0 0 " + this.$.mainSvg.offsetWidth 
				+ " " + currY);
		},
		
		updateTracks: function(index, threshold) {
			// index is the window index
			// only need to update tracks involved with that index
			if(index) {
				this.updateTracksInWindow(index, threshold);
			} else {
				this.trackDOMsByWindow.forEach(function(trackDOMs, windex) {
					this.updateTracksInWindow(windex, threshold);
				}, this);
			}
		},
		
		updateTracksInWindow: function(index, threshold) {
			// index is the window index
			// only need to update tracks involved with that index
			this.trackDOMsByWindow[index].forEach(function(trackDOM, tindex) {
				trackDOM.updateTracks(this.viewWindows[index], index);
			}, this);
		},
		
		trackReadyHandler: function(e) {
			// check if all tracks are ready, otherwise do nothing
			if(this.trackDOMs.every(function(trackDOM) {
				return trackDOM.isReady;
			}, this)) {
				this.updateHeightLocation();
			}
		},
		
		changeViewWindow: function(viewWindow, index) {
			this.viewWindows[index] = new ChrRegion(viewWindow, null, null, null, null, null, this.species)
			this.updateTracksInWindow(index, this.threshold);
		},
		
		changeAllViewWindows: function(viewWindows) {
			viewWindows.forEach(function(vwindow, index) {
				this.changeViewWindow(vwindow, index);
			}, this);
		},
		
		changeThreshold: function(threshold) {
			this.threshold = threshold || this.threshold;
			this.trackDOMs.forEach(function(trackDOM, index) {
				if(trackDOM.updateThreshold) {
					// is an interaction track
					trackDOM.updateThreshold(this.threshold);
				}
			}, this);
		},
		
		updateAll(viewWindows, threshold) {
			if(viewWindows) {
				this.changeAllViewWindows(viewWindows);
			}
			if(typeof(threshold) === 'undefined' || threshold === null) {
				threshold = this.threshold;
				if(!viewWindows) {
					this.updateTracks();
				}
			} else {
				this.changeThreshold(threshold);
			}
			return this.getViewWindowStrings();
		},
		
		getViewWindowStrings: function() {
			var result = [];
			this.viewWindows.forEach(function(vwindow, index) {
				result.push(vwindow.regionToString(false));
			}, this);
			return result;
		},
		
		changeSpecies: function(newSpecies, numOfSubs, viewWindow) {
			// this will reset all tracks and redo the species
			// note that the tracks should already be initialized before switching here
			if(!newSpecies) {
				throw("No new species specified!");
			}
			this.species = newSpecies;
			numOfSubs = numOfSubs || this.viewWindows.length;
			
			if(!viewWindow) {
				// viewWindow is not specified, then use the old viewWindows
				this.viewWindows = new Array(numOfSubs);
				this.viewWindows.fill(null);
				var defaultElem = this.species.defaultWindow || ['chr10:30000000-55000000', 'chr10:34900000-65000000'];
				this.viewWindows.forEach(function(vwindow, index) {
					var windowStr;
					if(typeof(viewWindow) === 'string') {
						// that's a single view window
						windowStr = viewWindow;
					} else if(Array.isArray(viewWindow) && viewWindow.length > 0) {
						// more than one viewWindows are specified
						windowStr = viewWindow[index];
					} else {
						// use default
						windowStr = defaultElem[index % defaultElem.length];
					}
					if(windowStr) {
						this.viewWindows[index] = new ChrRegion(windowStr, null, null, null, null, null, this.species);
					}
				}, this);
			} else {
				// but need to be clipped
				this.viewWindows.forEach(function(vwindow, index) {
					vwindow.clipRegion(this.species);
				}, this);
			}

			// notice that the tracks of species should be already initialized
			// so create a list of toggles to turn on/off all the tracks, and create a list of visible tracks
			this.resetDOM();
			return this.getViewWindowStrings();
			
		},
		
		resetDOM: function() {
			if(this.initialized) {
				this.trackDOMs = [];		// this is the array for visible tracks (DOMs with corresponding stuff)
											// every track is included
				this.trackDOMsByWindow = [];
												// this is the array for visible tracks by window
												// notice that this is an array of array
												// tracks are grouped by its corresponding viewWindow Index
				for(var i = 0; i < this.viewWindows.length; i++) {
					this.trackDOMsByWindow.push([]);
				}
				// enum all uniTracks of the species to generate the selection list, 
				// then populate this.visibleTracks
				this.viewWindows.forEach(function(vwindow, windowIndex) {
					// coordinate track
					this.addVisibleTrack(Track.createCoorTrack(this.species, 'coor_' + this.species.db + '_' + windowIndex), windowIndex);
					this.species.uniTracks.forEach(function(track, index) {
						// notice that if track type is 'interaction', it needs to be 'unshifted' to later windows
						if(track.getSetting('visibility') !== 'hide') {
							this.addVisibleTrack(track, windowIndex);
						}
					}, this);
				}, this);
				this.mergeTrackDOMsByWindow();
				
				while(Polymer.dom(this.$.mainSvg).firstChild) {
					Polymer.dom(this.$.mainSvg).removeChild(Polymer.dom(this.$.mainSvg).firstChild);
				}
				while(Polymer.dom(this.$.trackDOMHolder).firstChild) {
					Polymer.dom(this.$.trackDOMHolder).removeChild(Polymer.dom(this.$.trackDOMHolder).firstChild);
				}
				this.populateDOM();
			}
		},
		
		populateDOM: function() {
			this.trackDOMs.forEach(function(trackDOM, index) {
				Polymer.dom(this.$.trackDOMHolder).appendChild(trackDOM);
				Polymer.dom(this.$.mainSvg).appendChild(trackDOM.getTrackSvg());
			}, this);
			Polymer.dom.flush();
			// then update everything
			this.updateAll();
		},
		
		attached: function() {
			this.async(function() {
				// attach all trackDOMs
				this._setInitialized(true);
				this.resetDOM();
			});
		},
		
		// TODO: add/remove/rearrange tracks
		
	});
  </script>
</dom-module>
