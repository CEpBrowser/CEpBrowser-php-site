<link rel="import" href="./track-behavior.html">
<dom-module id="bed-track">
  <template>
  </template>
  <script>
  	BedTrack = Polymer({
		is: "bed-track",
		
		behaviors: [
			GIVeBehaviors.TrackBehavior
		],
		
		properties: {
		
			// data structure for bed tracks:
			// data has one key (chrom), all other keys will be deleted upon changing chromosome
			// data[chrom] is an array of Genes (for now)
			//		Future plan: arrays
			//		outside indices are start coordinates of every gene 
			//		inside indices are used if multiple genes start at the same location
			//		NOTICE: start is always smaller than end, if the strand is negative, start is TTS, end is TSS
			// 		values in the inner array are Gene objects 
			
		},
		
		created: function() {
			this.GENE_MARGIN = 10;
			this.GENE_NOTEXT_MARGIN = 2;
			this.ADAPTIVE_MAXLINES = 12;		// limit to downgrade visibility
			this.TRIANGLE_FILL = 0xFFFFFF;		// the fill color for the triangles (indicating clipped content)
			this.FORECOLOR_INDEX = 0;			// the color index for fore color
		},
		
		// ****** customized methods below ******
		
		dataHandler: function(e, detail) {
			// this is to handle data within response
			var res = detail.response;
			// first, purge buffer if different chromosome
			for(var chrom in this.data) {
				if(this.data.hasOwnProperty(chrom) && !res.hasOwnProperty(chrom)) {
					// not the same chromosome
					delete this.data[chrom];
				}
			}
			for(var chrom in res) {
				if(res.hasOwnProperty(chrom)) {
					this.data[chrom] = [];
					this.data[chrom].map = {};
					// TODO: use some better method to organize data
					// for now: enum all res.data, add them to this.data[chrom]
					res[chrom].forEach(function(transcript) {
						var newTrans = new Transcript(transcript.geneBed, null, null, null, null, null, 
																	this.track.species, transcript.geneSymbol);
						if(this.data[chrom].map.hasOwnProperty(transcript.geneSymbol) &&
							this.data[chrom].map[transcript.geneSymbol].overlaps(newTrans)) {
							this.data[chrom].map[transcript.geneSymbol].addTranscript(newTrans);
						} else {
							var newGene = new Gene(newTrans);
							this.data[chrom].push(newGene);
							this.data[chrom].map[newGene.name] = newGene;
						}
					}, this);
				}
			}
			
			this.bufferWindow = this.mainSvg.viewWindow.clone();
		},
		
		drawData: function() {
			// this is to draw everything from this.data to the svg
			// Steps:
			// 		put genes into lines (pack display)
			//		draw genes out line by line
			
			// clear text Margin svg
			this.clear();
			
			this.activeVisibility = this.track.getSetting('visibility');
			
			var lines;
			while(!(lines = this.prepareLines(this.data[this.mainSvg.viewWindow.chr])) && this.activeVisibility > Track.StatusEnum.VIS_NONE);
			var y = 0;
			lines.forEach(function(line) {
				line.genes.forEach(function(gene) {
					this.drawSingleGene(gene, y, this.FORECOLOR_INDEX);
				}, this);
				y += (this.fullHeight + this.textLineGap) * this.textSize;
			}, this);

			// resize the heights
			this.trackHeight = y - this.textLineGap * this.textSize;
			this.mainSvg.setAttributeNS(null, 'height', this.trackHeight);
			this.mainSvg.setAttribute("viewBox", "0 0 " + this.windowWidth + " " + this.trackHeight);
			if(this.textMargin) {
				this.textSvg.setAttributeNS(null, 'height', this.trackHeight);
				this.textSvg.setAttribute("viewBox", "0 0 " + this.textMargin + " " + this.trackHeight);
			}
			this.trackSvg.setAttributeNS(null, 'height', this.trackHeight);
			this.trackSvg.setAttribute("viewBox", "0 0 " + this.totalWidth + " " + this.trackHeight);
			
			// add labels (if visibility < noText)
			if(this.activeVisibility <= Track.StatusEnum.VIS_NOTEXT 
				&& this.activeVisibility > Track.StatusEnum.VIS_NONE) {
					this.drawShortLabel();
			}
		},
		
		// prepare genes
		
		prepareLines: function(genes) {
			// calculate the x0 and x1 for every gene, (taking text width into consideration)
			var lines = [{end: 0, genes: []}];		// arrays of objects {end: Number, genes: []}
			if(genes) {
				genes.every(function(gene) {
					
					var transcripts;
					if(this.activeVisibility > Track.StatusEnum.VIS_COLLAPSED) {
						// then transcripts needs to be drawn
						transcripts = gene.transcripts;
					} else {
						transcripts = [gene];
					}
					return transcripts.every(function(transcript, index) {
						// calculate x0 and x1 for the gene
						if(!this.regionInWindow(transcript)) {
							return true;
						}
						var x0 = this.transformXCoordinate({chr: transcript.chr, coor: transcript.start}, true),
							x1 = this.transformXCoordinate({chr: transcript.chr, coor: transcript.end}, true);
						if(this.activeVisibility > Track.StatusEnum.VIS_NOTEXT) {
							var newLabel = this.drawText(x0 - this.TEXT_MARGIN_GAP, this.Y_HIDDEN, 
														 transcript.getGeneName(true), "end");
							// move text to textMargin if out of bounds
							if(this.textMargin && newLabel.getBBox().x < 0) {
								x0 = 0;
							} else {
								x0 = newLabel.getBBox().x;
							}
							
							this.removeElement(newLabel);
						}
						
						if(!lines.some(function(line) {
							if(line.end <= x0 || this.activeVisibility <= Track.StatusEnum.VIS_DENSE) {
								// this gene can be fit into this line
								line.genes.push(transcript);
								line.end = x1 + (this.activeVisibility > Track.StatusEnum.VIS_NOTEXT? this.GENE_MARGIN: this.GENE_NOTEXT_MARGIN);
								return true;
							}
							return false;
						}, this)) {
							// no empty lines, create a new line
							if(this.isAdaptive && lines.length >= this.ADAPTIVE_MAXLINES) {
								this.activeVisibility--;
								lines = null;
								return false;
							}
							lines.push({end: x1 + this.GENE_MARGIN, genes: [transcript]});
						}
						return true;
					}, this);
				}, this);
			}
			
			return lines;
		},
		
		drawSingleGene: function(transcript, y, colorIndex, height, halfHeight) {
			// transcript: the transcript to be drawn
			// y: the y coordinate of the gene (line location)
			// height: the height of gene (notice that thin regions will have this.halfHeight * height)
			
			height = height || this.fullHeight * this.textSize * 0.8;
			halfHeight = halfHeight || this.halfHeight;
			if(typeof(colorIndex) !== 'number') {
				colorIndex = this.FORECOLOR_INDEX;
			}
			
			var coor, isThick = false, blockStart, blockEnd = transcript.start + transcript.blockStarts[0];
//			// draw thin segments (if any)
//			if(gene.thickStart > gene.start) {
//				coor = new ChrRegion(null, null, gene.chr, gene.start, gene.thickStart, gene.strand);
//				this.drawRectangle(coor, 0, y + height * 0.5 * halfHeight, height * halfHeight);
//			}
//			if(gene.thickEnd < gene.end) {
//				coor = new ChrRegion(null, null, gene.chr, gene.thickEnd, gene.end, gene.strand);
//			}
			
			// draw thick blocks and connecting lines
			for(var i = 0; i < transcript.numOfBlocks; i++) {
				blockStart = transcript.start + transcript.blockStarts[i];
				// first draw connecting lines (intron, if any)
				if(blockEnd < blockStart) {
					coor = new ChrRegion(null, null, transcript.chr, blockEnd, blockStart, transcript.strand);
					this.drawSpanningLine(coor, colorIndex, y, height);
				}
				blockEnd = blockStart + transcript.blockSizes[i];
				if(transcript.thickStart < blockEnd && transcript.thickStart > blockStart) {
					// CDS start is in this block
					coor = new ChrRegion(null, null, transcript.chr, blockStart, transcript.thickStart, transcript.strand);
					this.drawRectangle(coor, colorIndex, y + height * 0.5 * (1 - halfHeight), height * halfHeight, null, colorIndex);
					blockStart = transcript.thickStart;
				}
				if(transcript.thickEnd < blockEnd && transcript.thickEnd > blockStart) {
					// CDS end is in this block
					coor = new ChrRegion(null, null, transcript.chr, blockStart, transcript.thickEnd, transcript.strand, null, 0);
					this.drawRectangle(coor, colorIndex, y, height, null, colorIndex);
					blockStart = transcript.thickEnd;
				}
				
				isThick = (transcript.thickStart < blockEnd) && (transcript.thickEnd > blockStart);
				coor = new ChrRegion(null, null, transcript.chr, blockStart, blockEnd, transcript.strand);
				this.drawRectangle(coor, colorIndex, y + (isThick? 0: height * 0.5 * (1 - halfHeight)), 
									height * (isThick? 1: halfHeight), null, colorIndex);
				
			}
			
			// draw text
			if(this.activeVisibility > Track.StatusEnum.VIS_NOTEXT) {
				var newLabel = this.drawText(this.transformXCoordinate({chr: transcript.chr, coor: transcript.start}) - this.TEXT_MARGIN_GAP,
											 y + 0.5 * height, transcript.getGeneName(true), "end",
											 {style: "fill: " + this.rgbToHex(this.colorSet[colorIndex])});
				
				// move text to textMargin if out of bounds
				if(this.textMargin && newLabel.getBBox().x < 0) {
					newLabel.setAttributeNS(null, "x", this.textMargin);
					this.addElement(newLabel, this.textSvg);
				}
			}
			
			// draw triangle(s) indicating that the gene is not completely within the view
			if(this.transformXCoordinate({chr: transcript.chr, coor: transcript.start}, false) < 0) {
				// left triangle
				this.createRawPolymer(['0,' + (y + height * 0.5),
										height * 0.5 + ',' + y,
										height * 0.5 + ',' + (y + height * 0.5),
										height + ',' + y,
										height + ',' + (y + height), 
										height * 0.5 + ',' + (y + height * 0.5),
										height * 0.5 + ',' + (y + height), ], 
										null, null, null, this.TRIANGLE_FILL, this.colorSet[colorIndex]);
			}
			
			if(this.transformXCoordinate({chr: transcript.chr, coor: transcript.end}, false) > this.windowWidth) {
				// right triangle
				this.createRawPolymer([this.windowWidth + ',' + (y + height * 0.5),
										(this.windowWidth - height * 0.5) + ',' + y,
										(this.windowWidth - height * 0.5) + ',' + (y + height * 0.5),
										(this.windowWidth - height) + ',' + y,
										(this.windowWidth - height) + ',' + (y + height), 
										(this.windowWidth - height * 0.5) + ',' + (y + height * 0.5),
										(this.windowWidth - height * 0.5) + ',' + (y + height), ], 
										null, null, null, this.TRIANGLE_FILL, this.colorSet[colorIndex]);
			}

		},
		
		drawSpanningLine: function(region, colorIndex, y, height) {
			height = height || 1;
			y = y || 0;
			
			var svgToDraw = this.mainSvg;
			var windowToDraw = svgToDraw.viewWindow;
			
			if(windowToDraw.overlaps(region) > 0) {
				var x0 = this.transformXCoordinate(region.getStart(), true),
					x1 = this.transformXCoordinate(region.getEnd(), true);
				this.drawLine(x0, y + 0.5 * height, x1, y + 0.5 * height, this.colorSet[colorIndex]);
				this.drawStrandArrows(x0, y, x1, y + height, region.getStrand(), this.colorSet[colorIndex]);
			}
		},
		
	});
  </script>
</dom-module>
