<!--
@license
Copyright 2017 GIVe Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../paper-input/paper-input.html">
<link rel="import" href="../../paper-input/paper-input.html">
<link rel="import" href="../../genemo-data-components/basic-func/basic-func.html">
<link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../genemo-data-components/track-object/track-object.html">
<link rel="import" href="../ref-embedded-behavior/ref-embedded-behavior.html">
<link rel="import" href="../tutorial-highlight/tutorial-highlight.html">
<link rel="import" href="../../paper-spinner/paper-spinner.html">
<link rel="import" href="../../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../genemo-styles.html">
<link rel="import" href="genemo-track-styles.html">
<link rel="import" href="tracks-header.html">
<link href="https://fonts.googleapis.com/css?family=Roboto:500,400italic,700italic,700,400" rel="stylesheet" type="text/css">
<!--
### Overview

`<chart-area>` provides a Web Component element to interactively display genomic
data.

```html
<chart-area group-id-list='["genes", "singleCell"]' ref="mm10"></chart-area>
```

Although `<chart-area>` does not contain the navigational control elements as in `<chart-controller>`, users may still navigate by dragging and mouse-wheeling on the coordinates to move around.

Please refer to [`GIVe.RefEmbeddedBehavior`](../ref-embedded-behavior/index.html) for details on references used.

-->
<dom-module id="chart-area">
  <template>
    <style include="genemo-shared-styles">
      :host {
        position: relative;
        overflow-y: auto;
        font-family: 'Roboto', Arial, Helvetica, sans-serif;
        display: block;
        margin: 0;
        @apply(--layout-fit);
      }
      #trackDOMHolder {
        display: none;
      }
      paper-material {
        @apply(--layout-fit);
        padding: 0.8em;
        overflow-y: auto;
      }
      paper-material > div {
        padding: 0;
        width: 100%;
      }
      #loadingBlock {
        display: block;
        pointer-events: none;
        @apply(--layout-fit);
        z-index: 1;
        opacity: 0.8;
        background: var(--card-background-color);
      }
      paper-spinner {
        position: absolute;
        top: 50%;
        margin-top: -12px;
        left: 50%;
        margin-left: -12px;
        height: 24px;
        width: 24px;
        opacity: 1;
      }
      .uninitialized {
        font-size: 16px;
      }

    </style>
    <style include="genemo-track-styles"></style>
    <div id="loadingBlock" hidden$="[[readiness]]">
      <paper-spinner id="loadingSpinner" alt="Loading card content" active$="[[!readiness]]"></paper-spinner>
    </div>
    <paper-material>
      <div id="chartHoldingMaterial">
        <svg hidden$="[[!_initialized]]" id="mainSvg" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        </svg>
      </div>
      <div id="coorLocationHolder" hidden$="[[!_initialized]]"></div>
      <tutorial-highlight id="coorTrackTutorial" tutorial-key="coor-track-tutorial">
        <div>
          You may use mouse wheel within the coordinate track to zoom in/out, drag any track to move.
        </div>
      </tutorial-highlight>
      <div class="uninitialized" hidden$="[[_initialized]]">
        Please select a region to display first.
      </div>
    </paper-material>
    <div id="trackDOMHolder"></div>
  </template>
  <script>
    var GIVe = (function (give) {
      'use strict'

      give.ChartArea = Polymer({
        is: 'chart-area',

        behaviors: [
          Polymer.IronResizableBehavior,
          give.RefEmbeddedBehavior
        ],

        properties: {
          /**
           * The view windows to display in the element.
           * @type {Array<GIVe.ChromRegion>}
           */
          viewWindows: {
          // this will be an array of strings (viewWindowString),
          // may be changed to viewWindows directly for performance in the future
            type: Array,
            notify: true,
            value: function () {
              return []
            }
          },

          /**
           * The view windows to display in the element, in coordinate format.
           * This is for HTML attributes
           * @type {Array<string>}
           */
          coordinates: {
            type: Array,
            notify: true,
            value: function () {
              return []
            }
          },

          /**
           * The track groups included in the embedded browser. Group IDs are
           * specified in the data source. The data source on our server currently
           * provides these track groups:
           * *  `'genes'`: gene annotation tracks, for all available references
           * *  `'encode'`: ENCODE data sets for human and mouse, for `mm9` and `hg19` only
           * *  `'interaction'`: genomic interaction data sets, including those
           * generated from Hi-C (chromatin-chromatin) and MARGI (RNA-chromatin)
           * data, for `mm10`, `hg38` (MARGI) and `hg19` (Hi-C)
           * *  `'singleCell'`: mouse embryo single-cell RNA-seq data set from
           * [Biase *et al.*, *Genome Research*, **24**:1787-1796](http://genome.cshlp.org/content/24/11/1787.full),
           * for `mm10` only
           * @type {Array<string>}
           */
          groupIdList: {
            // this is the array of allowed group IDs in the list
            type: Array,
            value: function () {
              return []
            }
          },

          /**
           * Number of sub views in this controller.
           * Notice that if this setting is different from `coordinates.length`,
           * adjustments will be made to `coordinates` (truncating excessive
           * items or padding with default values).
           */
          numOfSubs: {
            type: Number,
            value: 1,
            notify: true,
            observer: '_numOfSubsChanged'
          },

          _initialized: {
            type: Boolean,
            value: false
          },

          _trackGap: {
            type: Number,
            value: 0.3    // unit is em
          },

          _textSize: {
            type: Number,
            value: 12    // unit is px
          },

          _threshold: {
            type: Number,
            value: 0.0
          },

          readiness: {
            type: Boolean,
            value: true,
            readOnly: true
          },

          firstRun: {
            type: Boolean,
            value: true,
            readOnly: true
          }
        },

        listeners: {
          'track-ready': '_trackReadyHandler',
          'update-window': '_updateWindowHandler',
          'iron-resize': '_onIronResize'
        },

        created: function () {
          this.svgNS = 'http://www.w3.org/2000/svg'
          this.trackDOMMap = {
            'bed': {
              prop: this._createBedTrackProp.bind(this),
              Ctor: give.BedTrackDOM,
              addDom: this._addOrdinaryTrackDOM.bind(this)
            },
            'wig': {
              prop: this._createWigTrackProp.bind(this),
              Ctor: give.WiggleTrackDOM,
              addDom: this._addOrdinaryTrackDOM.bind(this)
            },
            'bigwig': {
              prop: this._createWigTrackProp.bind(this),
              Ctor: give.BigWigTrackDOM,
              addDom: this._addOrdinaryTrackDOM.bind(this)
            },
            'genebed': {
              prop: this._createBedTrackProp.bind(this),
              Ctor: give.BedTrackDOM,
              addDom: this._addOrdinaryTrackDOM.bind(this)
            },
            'genepred': {
              prop: this._createBedTrackProp.bind(this),
              Ctor: give.BedTrackDOM,
              addDom: this._addOrdinaryTrackDOM.bind(this)
            },
            'interaction': {
              prop: this._createInteractionTrackProp.bind(this),
              Ctor: give.InteractionTrackDOM,
              addDom: this._addInteractionTrackDOM.bind(this)
            },
            'coordinate': {
              prop: this._createCoorTrackProp.bind(this),
              Ctor: give.CoorTrackDOM,
              addDom: this._addOrdinaryTrackDOM.bind(this)
            }
          }
          this.resizeDebounceInt = 100
          this.resizeJobName = 'RESIZE'
        },

        ready: function () {
          // initialize this.viewWindows from this.coordinates
          this.coordinates.forEach(function (coordinateStr, index) {
            if (give.ChromRegion.isValidChromRegion(coordinateStr) &&
              (!this.viewWindows[index] ||
                this.viewWindows[index].regionToString(false) !==
                new give.ChromRegion(coordinateStr, this._refObj).regionToString(false))) {
              this.splice('viewWindows', index, 1, new give.ChromRegion(coordinateStr, this._refObj))
            }
          }, this)
        },

        attached: function () {
          this.async(function () {
            // attach all trackDOMs
            this._checkVWindowsInit()
          })
        },

        _checkVWindowsInit: function () {
          if (!this._initialized) {
            if (this._refObj && this.viewWindows.every(function (vwindow) {
              return !!vwindow
            }, this)) {
              this._initialized = true
              this.resetDOM()
              return true
            } else {
              this._initialized = false
              return false
            }
          }
          return true
        },

        /**
         * Merge properties together
         * @todo Will be changed into `track-dom-behavior` or `basic-funcs`
         *
         * @param  {object} original - original object
         * @param  {object} newProp - object with new properties
         * @returns {object} object with the merged properties
         */
        _mergeProperty: function (original, newProp) {
          for (var key in newProp) {
            if (newProp.hasOwnProperty(key)) {
              original[key] = newProp[key]
            }
          }
          return original
        },

        _createBedTrackProp: function (viewWindowIndex, properties) {
          return this._mergeProperty({
            x: 0,
            y: 0,
            width: this.$.chartHoldingMaterial.clientWidth,
            textMargin: 100,
            requestUrl: give.TrackObject.fetchDataTarget,
            windowIndex: viewWindowIndex
          }, properties)
        },

        _createWigTrackProp: function (viewWindowIndex, properties) {
          return this._mergeProperty({
            x: 0,
            y: 0,
            width: this.$.chartHoldingMaterial.clientWidth,
            textMargin: 100,
            requestUrl: give.TrackObject.fetchDataTarget,
            windowIndex: viewWindowIndex
          }, properties)
        },

        _createCoorTrackProp: function (viewWindowIndex, properties) {
          return this._mergeProperty({
            x: 0,
            y: 0,
            width: this.$.chartHoldingMaterial.clientWidth,
            textMargin: 100,
            labelLocation: ((viewWindowIndex === 0) ? 'up' : 'down'),
            windowIndex: viewWindowIndex
          }, properties)
        },

        _createInteractionTrackProp: function (viewWindowIndex, properties) {
          return this._mergeProperty({
            x: 0,
            y: 0,
            width: this.$.chartHoldingMaterial.clientWidth,
            textMargin: 100,
            requestUrl: give.TrackObject.fetchDataTarget,
            numOfSubs: this.viewWindows.length,
            _threshold: this._threshold
          }, properties)
        },

        _createWiggleTrackProp: function (viewWindowIndex, properties) {
          return this._mergeProperty({
            x: 0,
            y: 0,
            width: this.$.chartHoldingMaterial.clientWidth,
            textMargin: 100,
            requestUrl: give.TrackObject.fetchDataTarget
          }, properties)
        },

        _createTrackProp: function (track, viewWindowIndex, props) {
          return this.trackDOMMap[track.getTypeTrunk()].prop(viewWindowIndex, props)
        },

        _createTrackDOM: function (track, viewWindowIndex, props) {
          return new this.trackDOMMap[track.getTypeTrunk()].Ctor(track,
                  this._createTrackProp(track, viewWindowIndex, props))
        },

        _addOrdinaryTrackDOM: function (trackDOM, viewWindowIndex) {
          this.trackDOMsByWindow[viewWindowIndex].splice(
            give.locationOf(trackDOM, this.trackDOMsByWindow[viewWindowIndex],
              null, null, function (trackDOM1, trackDOM2) {
                return give.TrackObject.comparePriorities(trackDOM1.track, trackDOM2.track, this._refObj.groups)
              }.bind(this)) + 1,
            0, trackDOM)
          this.trackDOMsByWindow[viewWindowIndex].map[trackDOM.track.id] = true
        },

        _addInteractionTrackDOM: function (trackDOM, viewWindowIndex) {
          // actually this will enum all viewWindowIndices
          this.viewWindows.forEach(function (vwindow, index) {
            this._addOrdinaryTrackDOM(trackDOM, index)
          }, this)
        },

        _addVisibleTrack: function (track, viewWindowIndex, forceAdd, props) {
          if (forceAdd || !this.trackDOMsByWindow[viewWindowIndex].map.hasOwnProperty(track.id)) {
            var newTrackDOM = this._createTrackDOM(track, viewWindowIndex, props)
            if (newTrackDOM) {
              this.trackDOMMap[track.getTypeTrunk()].addDom(newTrackDOM, viewWindowIndex)
            }
            return newTrackDOM
          }
        },

        _mergeTrackDOMsByWindow: function () {
          this.trackDOMs.splice(0, this.trackDOMs.length)
          this.trackDOMsByWindow.forEach(function (indTrackDOMs, windowIndex) {
            if (windowIndex !== 0) {
              indTrackDOMs = indTrackDOMs.slice().reverse()
            }
            indTrackDOMs.forEach(function (track, trackIndex) {
              if (!track._domMergeFlag) {
                this.trackDOMs.push(track)
                track._domMergeFlag = true
              }
            }, this)
          }, this)
          this.trackDOMs.forEach(function (track) {
            delete track._domMergeFlag
          }, this)
        },

        /**
         * Update the height and location of individual tracks
         *
         * @param  {number} width - Width of the current area
         */
        updateHeightLocation: function (width) {
          // calculate the heights for all tracks
          // note that by the time this is called, all tracks should be ready
          // (this is handled in track-ready event handler)
          // this will also rearrange the y value for all tracks as well
          width = width || this.$.chartHoldingMaterial.clientWidth
          var currY = 0
          this.trackDOMs.forEach(function (trackDOM, index) {
            trackDOM.updateLocationSize(0, currY, width)
            currY += trackDOM.getHeight() + this._trackGap * this._textSize
          }, this)
          currY -= this._trackGap * this._textSize
          this.$.mainSvg.setAttribute('height', currY)
          this.$.mainSvg.setAttribute('viewBox', '0 0 ' +
            this.$.chartHoldingMaterial.clientWidth + ' ' + currY)
        },

        /**
         * Refresh all tracks in a certain view or all views
         *
         * @param  {number|null} index - The index for the view being updated, use null for all views
         */
        _updateTracks: function (index) {
          // index is the window index
          // only need to update tracks involved with that index
          if (index) {
            this._updateTracksInWindow(index)
          } else {
            this.trackDOMsByWindow.forEach(function (trackDOMs, windex) {
              this._updateTracksInWindow(windex)
            }, this)
          }
        },

        /**
         * Refresh all tracks in a certain view
         *
         * @param  {number} index - The index for the view being updated
         */
        _updateTracksInWindow: function (index) {
          // index is the window index
          // only need to update tracks involved with that index
          this._setReadiness(false)
          this.trackDOMsByWindow[index].forEach(function (trackDOM, tindex) {
            trackDOM.updateTracks(this.viewWindows[index], index, this._threshold)
          }, this)
        },

        _trackReadyHandler: function (e) {
          // check if all tracks are ready, otherwise do nothing
          if (this.trackDOMs.every(function (trackDOM) {
            return trackDOM.isReady
          }, this)) {
            this.updateHeightLocation()
            if (this.firstRun) {
              this._setFirstRun(false)
              this.$.coorTrackTutorial.domTargetId = 'coor_' + this._refObj.db + '_0_mainSvg'
              this.$.coorTrackTutorial.showTutorial()
            }
            this._setReadiness(true)
          }
        },

        /**
         * Change the range of a sub view.
         * Range may be cropped if it exceed the maximum range allowed by the reference.
         *
         * @param  {string|GIVe.ChromRegion} viewWindow - The range to change into.
         * @param  {number} index - Index of the viewWindow.
         * @param  {boolean} forceDomReset - Whether to force the DOM to reload.
         * @return {string} The actual range (may be cropped by reference),
         *                   converted to string.
         */
        changeViewWindow: function (viewWindow, index, forceDomReset) {
          this.splice('viewWindows', index, 1, new give.ChromRegion(viewWindow, this._refObj))
          this.splice('coordinates', index, 1, this.viewWindows[index].regionToString(false))
          if (this._initialized && !forceDomReset) {
            this._updateTracksInWindow(index)
          } else {
            this._initialized = false
            this._checkVWindowsInit()
          }
          return this.viewWindows[index].regionToString(false)
        },

        /**
         * Change ranges in all views at once
         *
         * @param  {Array<string|GIVe.ChromObject>} viewWindows The ranges.
         * @return {Array<string>} The actual ranges, converted to `string`.
         */
        changeAllViewWindows: function (viewWindows) {
          viewWindows.forEach(function (vwindow, index) {
            this.changeViewWindow(vwindow, index)
          }, this)
          return this.getViewWindowStrings()
        },

        _changeThreshold: function (_threshold) {
          this._threshold = _threshold || this._threshold
          this.trackDOMs.forEach(function (trackDOM, index) {
            if (trackDOM.updateThreshold) {
            // is an interaction track
              trackDOM.updateThreshold(this._threshold)
            }
          }, this)
        },

        refreshAll: function (viewWindows, threshold) {
          if (typeof (threshold) !== 'undefined' && threshold !== null && !viewWindows) {
            // only update _threshold only
            this._changeThreshold(threshold)
            return this.getViewWindowStrings()
          } else {
            this._threshold = (typeof (threshold) !== 'undefined' && threshold !== null ? threshold : this._threshold)
            if (viewWindows) {
              this.changeAllViewWindows(viewWindows)
            } else {
              this._updateTracks()
            }
          }
          return this.getViewWindowStrings()
        },

        /**
         * Get the `string` of ranges in all views
         *
         * @returns {Array<string>} The ranges, converted to `string`.
         */
        getViewWindowStrings: function () {
          var result = []
          this.viewWindows.forEach(function (vwindow, index) {
            result.push(vwindow.regionToString(false))
          }, this)
          return result
        },

        /**
         * _numOfSubsChanged - sync number of viewWindows to `numOfSubs`
         *
         * @param  {type} newValue new `numOfSubs` value
         * @param  {type} oldValue old `numOfSubs` value
         */
        _numOfSubsChanged: function (newValue, oldValue) {
          if (this._refObj) {
            var defaultWindows = this._refObj.settings.defaultViewWindows
            for (var i = 0; i < newValue; i++) {
              if (this.coordinates[i] !== false &&
                !give.ChromRegion.isValidChromRegion(this.coordinates[i])) {
                this.splice('coordinates', i, 1, defaultWindows[i % defaultWindows.length])
                this.splice('viewWindows', i, 1, new give.ChromRegion(this.coordinates[i], this._refObj))
              }
            }
          }
        },

        _setRefObj: function (refObj) {
          this._refObj = refObj
          this._numOfSubsChanged(this.numOfSubs)
          this._initialized = false
          this._checkVWindowsInit()
        },

        /**
         * Reset the entire DOM display
         */
        resetDOM: function () {
          if (this._initialized) {
            this._setReadiness(false)
            this.trackDOMs = []     // this is the array for visible tracks (DOMs with corresponding stuff)
                                    // every track is included
            this.trackDOMsByWindow = []
            // this is the array for visible tracks by window
            // notice that this is an array of array
            // tracks are grouped by its corresponding viewWindow Index
            for (var i = 0; i < this.viewWindows.length; i++) {
              this.trackDOMsByWindow.push([])
              this.trackDOMsByWindow[i].map = {}
            }

            this.viewWindows.forEach(function (vwindow, windowIndex) {
              // coordinate track
              var coorTrackDOM = this._addVisibleTrack(give.TrackObject.createCoorTrack(this._refObj,
                'coor_' + this._refObj.db + '_' + windowIndex), windowIndex)
              if (!windowIndex) {
                this.coorTrackZeroDOM = coorTrackDOM
              }
            }, this)

            this.addAllTrackDOMs()
          } else {
            this._setReadiness(true)
          }
        },

        _clearDOM: function () {
          while (Polymer.dom(this.$.mainSvg).firstChild) {
            Polymer.dom(this.$.mainSvg).removeChild(Polymer.dom(this.$.mainSvg).firstChild)
          }
          while (Polymer.dom(this.$.trackDOMHolder).firstChild) {
            Polymer.dom(this.$.trackDOMHolder).removeChild(Polymer.dom(this.$.trackDOMHolder).firstChild)
          }
        },

        _addAllTrackDOMsTracksReady: function (noRefreshContent) {
          // function called when tracks are ready for this._refObj
          var showTrack = function (wIndex, track, index) {
            // notice that if track type is 'interaction', it needs to be 'unshifted' to later windows
            if (track.getSetting('visibility') > give.TrackObject.StatusEnum.VIS_NONE) {
              this._addVisibleTrack(track, wIndex)
            }
          }
          this.viewWindows.forEach(function (vwindow, windowIndex) {
            if (this.groupIdList && this.groupIdList.length > 0) {
              this.groupIdList.forEach(function (groupID) {
                if (this._refObj.getGroups().hasOwnProperty(groupID)) {
                  this._refObj.getGroups()[groupID].forEach(
                    showTrack.bind(this, windowIndex), this)
                }
              }, this)
            } else {
              this._refObj.getTracks().forEach(
                showTrack.bind(this, windowIndex), this)
            }
          }, this)
          this._mergeTrackDOMsByWindow()
          this.populateDOM(noRefreshContent)
        },

        addAllTrackDOMs: function (noRefreshContent) {
          this._refObj.callOnTracksReady(this._addAllTrackDOMsTracksReady.bind(this, noRefreshContent))
        },

        _removeInvisibleTrackDOMs: function () {
          this.trackDOMsByWindow.forEach(function (indTrackDOMs, windowIndex) {
            // notice that because tracks may get deleted, don't use forEach with splice
            var i
            for (i = indTrackDOMs.length - 1; i >= 0; i--) {
              if (indTrackDOMs[i].track.getSetting('visibility') === give.TrackObject.StatusEnum.VIS_NONE) {
                // this track should be hidden by now
                delete indTrackDOMs.map[indTrackDOMs[i].track.id]
                indTrackDOMs.splice(i, 1)
              }
            }
          }, this)
        },

        populateDOM: function (noRefreshContent) {
          // first clear old DOMs
          this._clearDOM()
          // then populate all new DOMS
          this.trackDOMs.forEach(function (trackDOM, index) {
            Polymer.dom(this.$.trackDOMHolder).appendChild(trackDOM)
            Polymer.dom(this.$.mainSvg).appendChild(trackDOM.getTrackSvg())
          }, this)
          Polymer.dom.flush()
          if (!noRefreshContent) {
            // then update everything
            this.refreshAll()
          }
        },

        updateDOM: function (noRefreshContent) {
          // update existing DOMs, first remove all tracks that should be hidden
          // if noRefreshContent = true, do not refresh content (should be refreshed later)
          if (this.trackDOMs.length > 0) {
            this._removeInvisibleTrackDOMs()
          }

          // then add new Tracks (if not there already)
          this.addAllTrackDOMs(noRefreshContent)
        },

        _updateWindowHandler: function (e) {
          // update the windows by events bubbled up from bottom tracks
          try {
            if (e.detail.newWindow instanceof give.ChromRegion ||
              typeof e.detail.newWindow === 'string') {
              this.changeViewWindow(e.detail.newWindow,
                (!isNaN(parseInt(e.detail.windowIndex)) && parseInt(e.detail.windowIndex) >= 0)
                  ? parseInt(e.detail.windowIndex)
                  : 0, !!(e.detail.tracks)
              )
            }
          } catch (err) {
            console.log(err.message)
            console.log(err.stack)
          }
        },

        _onIronResize: function (e, detail) {
          if (this.trackDOMs) {
            this.debounce(this.resizeJobName, this.updateHeightLocation.bind(this), this.resizeDebounceInt)
          }
        }

      // TODO: add/remove/rearrange tracks

      })

      return give
    })(GIVe || {})
  </script>
</dom-module>
