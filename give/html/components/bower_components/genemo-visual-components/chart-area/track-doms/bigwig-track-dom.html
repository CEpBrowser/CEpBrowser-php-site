<link rel="import" href="track-dom-behavior.html">
<!--
bigwig-track-dom takes data from a track.data and displays it accordingly.




-->
<dom-module id="bigwig-track-dom">

  <template>
  </template>
  <script>
    var GIVe = (function (give) {
      'use strict'

      give.BigWigTrackDOM = Polymer({ // and fix usage of detail, reader, results, etc.

        is: 'bigwig-track-dom',
        behaviors: [
          give.TrackDOMBehavior
        ],
        properties: {
        },
        created: function () {
          this.MARGIN = 2
          this.FORECOLOR_INDEX = 0 // the color index for fore color
          this.TEXT_COLOR_RGB = 0 // the color index for text
          this.OVERFLOW_COLOR_INDEX = 7 // the color index for overflow (red)

          /**
           * the width of the line that is used for the overflow
           */
          this.OVERFLOW_STROKE_WIDTH = 4

          /**
           * to be explained
           */
          this.SCALE_TEXT_SIZE = 9

          /**
           *     to be explained
           */
          this.MIN_RESOLUTION_PER_PIXEL = 2
        },
        /**
         * anonymous function - description
         *
         * @param  {type} track description
         * @param  {type} prop  description
         * @return {type}       description
         */
        trackImpl: function (track, prop) {

          /**
           * The upper bound for the track display. Any values above this will be displayed as a overflow line.
           */
          this.windowMax = 20

          /**
           * The lower bound for the track display. One might think that this is obviously zero, but in some cases there are actually negative intensity values at a point.
           */
          this.windowMin = 0

          /**
           * The height of the track, presumably in pixels. This is not the same as the window bounds, which are instead the bounds for the actual data values. If the difference between the windowMax and the windowMin is 20, and the track height is 80, then four pixels would represent one 'unit'.
           */
          this.trackHeight = 80

          /**
           * to be explained
           */
          this.scaleTickLength = 5

          /**
           *  A simple calculation of where the top and bottom of where to draw the track is.
           */
          this.drawingBoundary = {top: this.MARGIN, bottom: this.trackHeight - this.MARGIN}

          /**
           * to be explained
           */
          this.windowRange = 0

          /**
           * Whether or not to automatically scale the window bounds according to the data displayed.
           */
          this.autoScale = false

          /**
           * The amount of points used around one point; an average value of the points is displayed rather than the actual value at any given point.
           */
          this.averagePointAmount = 10
          this.slidingWindowWidth = 5   // sliding window size (single side)
          this.dataPoints = []
  // this.dataPoints=[]
        },

        /**
         * anonymous function - description
         *
         * @return {type}  returns the resolution.
         */
        getCurrentResolutions: function () {
          return Math.floor(this.mainSvg.viewWindow.getLength() / this.MIN_RESOLUTION_PER_PIXEL / this.windowWidth)
        },

        /**
         * anonymous function - draw the given point with height determined by signal strength
         *
         * @return {type}  does not return anything.
         */
        getCurrentPixelLength: function () {
          return Math.ceil(this.mainSvg.viewWindow.getLength() / this.windowWidth)
        },

        generateSmoothedPoints: function () {
          // Get the smoothing points
          var rawDataPoints = []
          var smoothedDataPoints = []
          var vwindow = this.mainSvg.viewWindow
          var extensionSpan = Math.max(this.getCurrentPixelLength *
            this.slidingWindowWidth, this.slidingWindowWidth)

          // First populate the raw data points
          this.track.data[vwindow.chr].traverse(vwindow.getExtension(extensionSpan),
            rawDataPoints.push, null, this.getCurrentResolutions(),
            rawDataPoints, false)

          // Then smooth out with this.slidingWindowWidth

        },

        drawData: function () {
        // draw the given point with height determined by signal strength
          this.clear()
          var vwindow = this.mainSvg.viewWindow

          if (this.track.data.hasOwnProperty(vwindow.chr)) {
            var updateExtreme = function (dataSegment) {
              var yvalue
              if (dataSegment.data instanceof give.TrackObjectImpl._BigWigImpl.SummaryCtor) {
                yvalue = dataSegment.data.sumData / dataSegment.getLength()
              } else {
                yvalue = dataSegment.data.value
              }
              if (Math.ceil(yvalue) > this.windowMax) {
                this.windowMax = Math.ceil(yvalue)
              }
              if (Math.floor(yvalue) < this.windowMin) {
                this.windowMin = Math.floor(yvalue)
              }
            }.bind(this)

            if (this.autoScale) {
              this.windowMax = Number.NEGATIVE_INFINITY
              this.windowMin = Number.POSITIVE_INFINITY
              this.track.data[vwindow.chr].traverse(vwindow, updateExtreme, null,
                this.getCurrentResolutions(), this, false)
              if (this.windowMax === Number.NEGATIVE_INFINITY) {
                this.windowMax = 1
                this.windowMin = 0
              }
            }

            var polygon = {}

            this.track.data[vwindow.chr].traverse(vwindow.getExtension(0.1, null, true), this.addPoint.bind(this),
                                null, this.getCurrentResolutions(), this, false)
            this.averagePoints()
            /* this.track.data[vwindow.chr].traverse(vwindow, this.drawPeak.bind(this, polygon),
                          null, this.getCurrentResolutions(), this, false)
            this.drawPeak(polygon)  // finish up the last polygon */
            for (var i = 0; i < this.track.data[vwindow.chr].averageDataPoints.length; i++) {
              if (this.track.data[vwindow.chr].averageDataPoints[i].getStart() >= vwindow.start && this.track.data[vwindow.chr].averageDataPoints[i].getEnd() < vwindow.end) {
                this.drawPeak(polygon, this.track.data[vwindow.chr].averageDataPoints[i])
              }
            }
          }
          this.drawScale()

          if (this.textSvg) {
            this.drawShortLabel(null, this.textMargin - this.MARGIN - this.TEXT_MARGIN_GAP)
          }
        // shape.push([0,this.windowWidth]);
        // this.createRawPolymer([shape, null, null, null, this.TRIANGLE_FILL, this.colorSet[colorIndex]], 1);
        },

        /**
         * anonymous function - transforms a signal strength into a y coordinate on the svg.
         *
         * @param  {type} signal signal strength
         * @param  {type} flags  has two booleans
         * @return {type}        returns the y coordinate
         */
        transformYCoordinate: function (signal, flags) {
        // transform Y coordinate from signal with this.windowMin and this.windowMax
        // notice that if the value exceeds either boundary,
        // it will return the Y value at the boundary, but will mark flags.EXCEED_MAX or flags.EXCEED_MIN as true
        // (flags needs to be an object from the caller to receive such values)
          flags = flags || {}
          delete flags.EXCEED_MIN
          delete flags.EXCEED_MAX  // clear flags first
          if (signal > this.windowMax) {
            flags.EXCEED_MAX = true
            return this.drawingBoundary.top
          } else if (signal < this.windowMin) {
            flags.EXCEED_MIN = true
            return this.drawingBoundary.bottom
          }
          return (signal - this.windowMax) / (this.windowMin - this.windowMax) *
          (this.drawingBoundary.bottom - this.drawingBoundary.top) + this.drawingBoundary.top
        },

        /**
         * anonymous function - scales a line to be drawn based on window ranges, assuming autoscale is being used.
         *
         * @param  {type} strength description
         * @param  {type} extremes description
         * @return {type}          description
         */
        scaleLine: function (strength, extremes) {
          var zero, value
          if (extremes[0] < 0 && extremes[1] > 0) { // if range is from - to +
            zero = ((0 - extremes[0]) / extremes[3] * this.height)
            value = ((value - extremes[0]) / extremes[3] * this.height)
          } else { // if range is only + or only -
            if (extremes[0] > 0 && extremes[1] > 0) { // if range is only +
              zero = 0
              value = (value / extremes[1] * this.height)
            } else if (extremes[0] > 0 && extremes[1] > 0) { // if range is only -
              zero = this.height
              value = this.height - (value / extremes[1] * this.height)
            } else {
            // there is something wrong
            }
          }
          return [this.height - zero, this.height - value]
        },

        /**
         * anonymous function - scales a line to be drawn based on the custom window range.
         *
         * @param  {type} strength description
         * @return {type}          description
         */
        scaleLineCustom: function (strength) {
          var zero = 0
          var value = 0
          var cutOff = 0
          zero = this.windowMax / this.windowRange * this.trackHeight
          value = (this.windowMax - strength) / this.windowRange * this.trackHeight
          if (this.windowMax < 0) {
            zero = 0
            cutOff += 1
          }
          if (this.windowMin > 0) {
            zero = this.trackHeight
            cutOff -= 1
          }
          if (strength > this.windowMax) {
            value = 0
            cutOff += 1
          }
          if (strength < this.windowMin) {
            value = this.trackHeight
            cutOff -= 1
          }
          if ((this.windowMin > 0 && strength > this.windowMax) || (this.windowMax < 0 && strength < this.windowMin)) {
            cutOff += 3
          }
          return [zero, value, cutOff]
        },

        /**
         * anonymous function - Draws the horizontal thick, diferent colored lines where the values go further than the window ranges.
         *
         * @param  {type} overflows the list of overflow areas
         * @return {type}           description
         */
        drawOverflowLines: function (overflows) {
        // overflows is an object containing overflowing ChrRegions
        // { 'exceedMax': Array(), 'exceedMin': Array() }
        // purple

          var drawOverflowRect = function (y, region) {
            this.drawRectangle(region, this.rgbToHex(this.colorSet[this.OVERFLOW_COLOR_INDEX]),
              y, this.OVERFLOW_STROKE_WIDTH, this.mainSvg)
          }.bind(this)
          overflows.exceedMax.forEach(drawOverflowRect.bind(null, 0))
          overflows.exceedMin.forEach(drawOverflowRect.bind(null, this.trackHeight - this.OVERFLOW_STROKE_WIDTH))
        },

        /**
         * anonymous function - Adds a point from the dataEntry to the datapoints.
         *
         * @param  {type} dataEntry holds many points, just not in the correct format (yet).
         * @return {type}           description
         */
        addPoint: function (dataEntry) {
      /* var x = dataEntry.getStart()
      var y = dataEntry.getEnd()
      var z = dataEntry.data instanceof give.TrackObjectImpl._BigWigImpl.SummaryCtor
          ? dataEntry.data.sumData / dataEntry.getLength() : dataEntry.data.value */
          var vwindow = this.mainSvg.viewWindow
          this.track.data[vwindow.chr].dataPoints.push(dataEntry)
        },

        /**
         * anonymous function - Takes a specified amount of points (by averagePointAmount) around the point and assigns the average y value of all those points to the middle point's display.
         * An even amount of points will mean taking an extra point to the left in the average.
         *
         * @return {type}  description
         */
        averagePoints: function () {
          var splitAmount = Math.ceil((this.averagePointAmount - 1) / 2)
          var vwindow = this.mainSvg.viewWindow
          this.track.data[vwindow.chr].averageDataPoints = []
          for (var i = splitAmount; i < this.track.data[vwindow.chr].dataPoints.length - splitAmount - 1; i++) {
            var temp = this.track.data[vwindow.chr].dataPoints[i]
            var sum = 0
            for (var j = 0; j < this.averagePointAmount; j++) {
              sum += this.track.data[vwindow.chr].dataPoints[i - splitAmount + j].data.value
            }
            temp.data.value = parseInt(sum / this.averagePointAmount + 0.5)
            this.track.data[vwindow.chr].averageDataPoints.push(temp)
          }
        },

        /**
         * anonymous function - Draws the given points onto the svg window.
         *
         * @param  {type} currPolygon description
         * @param  {type} dataEntry   description
         * @return {type}             description
         */
        drawPeak: function (currPolygon, dataEntry) {
          var svgToDraw = this.mainSvg
          var windowToDraw = svgToDraw.viewWindow
          var flags = {}

          currPolygon = currPolygon || {}
          if (!currPolygon.hasOwnProperty('points')) {
            currPolygon.points = []
          }

          var start = dataEntry ? Math.max(dataEntry.getStart(), windowToDraw.getStart()) : windowToDraw.getEnd() + 1
          var end = dataEntry ? Math.min(dataEntry.getEnd(), windowToDraw.getEnd()) : windowToDraw.getEnd() + 2
          if (start < end) {
            if (currPolygon.points.length > 0) {
            // old polygon is there
              if (currPolygon.lastX < start) {
              // it's a separate polygon
                currPolygon.points.push(
                this.transformXCoordinate({chr: windowToDraw.chr, coor: currPolygon.lastX}, false) +
                ',' + this.transformYCoordinate(0))
                this.createRawPolygon(currPolygon.points, {class: 'wiggleShapes',
                  fill: this.rgbToHex(this.colorSet[0]),
                  stroke: this.rgbToHex(this.colorSet[0])
                }, svgToDraw)
                this.drawOverflowLines(currPolygon.overflows)
                currPolygon.points = []
              }
            }
            if (dataEntry && dataEntry.chr === windowToDraw.chr) {
              var yvalue = dataEntry.data instanceof give.TrackObjectImpl._BigWigImpl.SummaryCtor
                ? dataEntry.data.sumData / dataEntry.getLength() : dataEntry.data.value
              if (currPolygon.points.length <= 0) {
              // start a new polygon, push the (x, 0) point of this segment
                currPolygon.points.push(
                this.transformXCoordinate({chr: windowToDraw.chr, coor: start}, false) +
                ',' + this.transformYCoordinate(0))
                currPolygon.overflows = {exceedMax: [], exceedMin: []}
              }
            // then push the top two points
              if (/* this.transformXCoordinate({chr: windowToDraw.chr, coor: end}) -
                this.transformXCoordinate({chr: windowToDraw.chr, coor: start}) < 1 */true) {
                // both are within one pixel
                currPolygon.points.push(
                this.transformXCoordinate({chr: windowToDraw.chr, coor: (start + end) / 2}, false) +
                ',' + this.transformYCoordinate(yvalue, flags))
              } else {
                currPolygon.points.push(
                this.transformXCoordinate({chr: windowToDraw.chr, coor: start}, false) +
                ',' + this.transformYCoordinate(yvalue, flags))
                currPolygon.points.push(
                this.transformXCoordinate({chr: windowToDraw.chr, coor: end}, false) +
                ',' + this.transformYCoordinate(yvalue, flags))
              }
              currPolygon.lastX = end
            }
          }
        // process overflows
          if (flags.EXCEED_MIN) {
            var lastExceed = currPolygon.overflows.exceedMin[currPolygon.overflows.exceedMin.length - 1]
            if (!lastExceed || !lastExceed.concat(dataEntry)) {
              currPolygon.overflows.exceedMin.push(dataEntry.clone())
            }
          } else if (flags.EXCEED_MAX) {
            lastExceed = currPolygon.overflows.exceedMax[currPolygon.overflows.exceedMax.length - 1]
            if (!lastExceed || !lastExceed.concat(dataEntry)) {
              currPolygon.overflows.exceedMax.push(dataEntry.clone())
            }
          }

          return true
        },

        /**
         * anonymous function - Draws the signal strength scale on the left side of the track.
         *
         * @return {type}  description
         */
        drawScale: function () {
          if (this.textSvg) {
          // first draw the lines
            this.drawLine(this.textMargin - this.MARGIN, this.drawingBoundary.top,
                 this.textMargin - this.MARGIN, this.drawingBoundary.bottom,
                 this.TEXT_COLOR_RGB, this.textSvg)
            this.drawLine(this.textMargin - this.MARGIN - this.scaleTickLength, this.drawingBoundary.top,
                 this.textMargin - this.MARGIN, this.drawingBoundary.top,
                 this.TEXT_COLOR_RGB, this.textSvg)
            this.drawLine(this.textMargin - this.MARGIN - this.scaleTickLength, this.drawingBoundary.bottom,
                 this.textMargin - this.MARGIN, this.drawingBoundary.bottom,
                 this.TEXT_COLOR_RGB, this.textSvg)

          // then the text
            this.drawText(this.textMargin - this.MARGIN - this.scaleTickLength - this.TEXT_MARGIN_GAP,
                  this.drawingBoundary.top + this.textSize * 0.4, this.windowMax.toString(),
                  'end', null, this.textSvg)
            this.drawText(this.textMargin - this.MARGIN - this.scaleTickLength - this.TEXT_MARGIN_GAP,
                  this.drawingBoundary.bottom - this.textSize * 0.4, this.windowMin.toString(),
                  'end', null, this.textSvg)
          }
        },

        /**
         * anonymous function - Sets the window range.
         *
         * @param  {type} min description
         * @param  {type} max description
         * @return {type}     description
         */
        setExtremes: function (min, max) {
          if (max > min) {
            this.windowMin = min
            this.windowMax = max
            this.windowRange = max - min
            this.autoScale = false
          } else {} // there is an error
        },

        /**
         * anonymous function - Automatically scales the window, taking the maximum and minimum signal strengths in the display window as the range extremes.
         *
         * @return {type}  description
         */
        autoWindow: function () {
          this.autoScale = true
        }

      })

      return give
    })(GIVe || {})
  </script>
</dom-module>
